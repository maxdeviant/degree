
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
<title>Data Structures - Deques &amp; Stack Algorithms</title>
<link rel="stylesheet" type="text/css" href="/~rkline/css/basic.css" />
<link rel="stylesheet" type="text/css" href="/~rkline/css/init.css" />
<link href="/~rkline/images/favicon.ico" rel="shortcut icon" type="image/icon" />
<link href="/~rkline/css/java.css" media="all" rel="stylesheet" type="text/css" />
<style type="text/css" media="print">
/* override other settings to make print-friendly appearance */
body { padding: 10px 20px; }
.print_hide { display: none; }
div.print_only { display: block; }
#header { margin-top: 0px; height: 30px; }
#content { margin-top: 25px; }
</style>
</head>
<body>

<div id="header">
<h2 style='margin:0'>
Deques &amp; Stack Algorithms</h2>
<div id="mtime">last modified: Feb 11, 2013</div>

<div id="toggle_all" class='print_hide'>
<a href="#">
toggle show-hides
</a>
</div>



<div id="sections" class='print_hide'>
<select name="sections">
<option value="">--- select a section ---</option>
<option value="#arraydeque">ArrayDeque operations</option>
<option value="#arraydeque-descrip">ArrayDeque Description</option>
<option value="#adeque">ArrayDeque implementation (ADeque)</option>
<option value="#stack-algorithms">Stack Algorithms</option>
<option value="#arith-eval">Arithmetic Expression Evaluation</option>
</select>
</div>

</div>

<div id="content">
<h3><a name="arraydeque"></a>ArrayDeque operations</h3>
The <tt>ArrayDeque</tt> is the array-based implementation.
of the <tt>Deque</tt> interface. Perhaps its key feature is
the ability to execute the <tt>addFirst</tt> and <tt>removeFirst</tt>
operations in <b>constant</b> time, which is something the 
<tt>ArrayList</tt> cannot do.
<p>
</p>
Both <tt>LinkedList</tt> and <tt>ArrayDeque</tt> 
are common <tt>Deque</tt> implementations.
As noted in the <a href="linked-lists.html">Linked Lists</a>
document, a <tt>Deque</tt> focuses on list access at the ends.
The <tt>ArrayDeque</tt>, unlike the <tt>LinkedList</tt>, 
does <b>not</b> implement the <tt>List</tt> interface, and so we never think
about using it for positional access.
<p></p>
Common subsets of the intended operations are these:
<div class="n" style='margin-bottom:0'>
<i>stack mode</i>, 
provided by the <tt>Deque</tt> interface:
<pre class='n'>
boolean push(e),  E pop(),  E element(),  boolean isEmpty()
</pre>
<i>queue mode</i>, 
provided by both the <tt>Queue</tt> and <tt>Deque</tt> interfaces:
<pre class='n' style='margin-bottom:0'>
boolean add(e),  E remove(),  E element(),  boolean isEmpty()
</pre>
</div>
The difference is that in stack mode, the <tt>push</tt> and <tt>pop</tt>
operations do the element addition/removal to the <b>same</b> end, 
whereas in queue mode the <tt>add</tt> and <tt>remove</tt> operations
affect <b>opposite</b> ends. 
The function <tt>getFirst</tt>
is an alternative for <tt>element</tt>, except that 
it is not, per se, defined by the <tt>Queue</tt> interface.
<p>
</p>
In a valid <tt>Deque</tt> implementation, there is no
difference between the "first" and "last" ends of
the list, but Java makes these choices:
<div class="n lh3">
stack: operations access the <b>first</b> end
<br />
queue: add to the <b>last</b> end, remove from the <b>first</b> end
</div>
Here is a visual depiction of the operations:
<div class="n">
<img src="/~rkline/DS/images/stack-queue.jpg" />
</div>
The <tt>Deque</tt> implementations (<tt>LinkedList</tt> and
<tt>ArrayDeque</tt>) serve for either queue or stack usage.
Java does have a <tt>Stack</tt> class but it is <b>deprecated</b> and 
should not be used. 

In the literature,
the term <b>LIFO</b> (<b>L</b>ast <b>I</b>n <b>F</b>irst <b>O</b>ut)
is used to refer to the stack-mode access whereas
<b>FIFO</b> (<b>F</b>irst <b>I</b>n <b>F</b>irst <b>O</b>ut)
refers to queue-mode access.
Also in the literature, <tt>top</tt> is often used as the name of
the element retrieval operation.
Other languages, like Php, Perl and Python 
use the "last" end for stack operations (Python prefers "append" to "push").
The <tt>Queue</tt> interface also supports
the <tt>PriorityQueue</tt> implementation class, which is 
not a FIFO queue like the
<tt>LinkedList</tt> and <tt>ArrayDeque</tt> classes.


<h3>Demo program</h3>
Create a NetBeans project <tt>ADequeDemo</tt>. 
Assuming you use the default setup of NetBeans, the main class will be
named <tt>ADequeDemo</tt>.
Change the content to the following:

<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="ADequeDemo/src/adequedemo/ADequeDemo.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
adequedemo.ADequeDemo</span>
<a href="/~rkline/ds/showhide/target/deque-stack-algorithms">(click to show)</a>
</form>
<div></div>
</div>
</div>

This demo program illustrates two <tt>ArrayDeque</tt> objects, 
one in stack mode, the other in queue mode.

<h3><a name="arraydeque-descrip"></a>ArrayDeque Description</h3>

For an array to act like a <tt>Deque</tt>, 
the simplest idea would be for it to
allow an arbitrary range of positive and negative indices.
For example, suppose we start with an empty array of capacity 40 in which
we  do 30 
<tt>addLast</tt> 
operations, getting:
<div class="n">
<table width="100%">
<tr>
<td width="20%" style="background-color:#cccccc"><hr /></td>
<td width="50%" style="background-color:yellow"><hr /></td>
<td width="20%" style="background-color:#cccccc"><hr /></td>
 <td width="0%"></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>30</td>
<td>40</td>
</tr>
</table>
</div>
After 
5 <tt>removeLast</tt> 
and 
3 <tt>addFirst</tt>
operations, if negative indices were allowed:
<div class="n">
<table width="100%">
<tr>
<td width="12%"  style="background-color:#cccccc"><hr /></td>
<td width="48%"  style="background-color:yellow"><hr /></td>
<td width="30%"  style="background-color:#cccccc"><hr /></td>
<td width="0%"></td>
</tr>
<tr>
<td></td>
<td>-3</td>
<td>25</td>
<td>40</td>
</tr>
</table>
</div>
In order to create the effect of negative indices without <i>actual</i> negative
indices, we make the array "form a circle" 
shifting the "virtual"
indices -1, -2, ... into the array from above like this:
<div class="n">
<table width="100%">
<tr>
<td width="20%" style="background-color:black"><hr /></td>
<td width="40%"  style="background-color:yellow"><hr /></td>
<td width="22%"  style="background-color:#cccccc"><hr /></td>
<td width="8%"  style="background-color:yellow"><hr /></td>
<td width="0%"></td>
</tr>
<tr>
<td></td>
<td>0</td>
<td>25</td>
<td>37</td>
<td>40</td>
</tr>
</table>
</div>
The negative indices are mapped to non-negative indices by 
"adding <tt>capacity</tt>", e.g.:
<pre class='n'>
-1  &rarr;  -1 + 40 = 39
-2  &rarr;  -2 + 40 = 38
-3  &rarr;  -3 + 40 = 37
</pre>
In particular, we write our own 
<b>inc</b>rement and <b>dec</b>rement
operations on an <tt>index</tt> in order to create the "wrap-around" effect:
<pre class="lh3 n">
private int inc(int i) { return (i == capacity - 1) ? 0 : i+1; }
private int dec(int i) { return (i == 0) ? capacity - 1 : i-1; }
</pre>
We also need two markers to identify the start and end of the content:
<div class="n lh3">
<tt>low</tt>: array position of data for the <tt>getFirst,addFirst,removeFirst</tt> operations
<br />
<tt>high</tt>: array position <b>after</b> data for <tt>getLast,addLast,removeLast</tt> operations
</div>
In our above example we would have the values:
<pre class='n'>
low  = 37
high = 25
size = 28
</pre>
<table>
<tr valign="top">
<td style='width:240px;padding-top:10px'>
The best way to conceive of how an ArrayDeque works is by visualizing
it as a circle created by connecting the ends of the array.
<p></p>
In a non-empty ArrayDeque, the content is specified by
elements in positions <tt>low</tt> (inclusive) 
to <tt>high</tt> (exclusive) going clockwise.
</td>
<td>
<img src="/~rkline/DS/images/arraydeque1.jpg" 
     height="325px" />
</td>
</tr>
</table>
<div class='n'>
</div>

<h4 style='margin-top:0'>Full and empty</h4>
The <i>empty</i> and <i>full</i> states of the ArrayDeque
are characterized by having <tt>low</tt> and <tt>high</tt> equal.
We use the <tt>size</tt> parameter to differentiate between them:
<ul class="notes">
<li>empty: <tt>size == 0</tt> and <tt>low == high</tt>
</li>
<li>full: <tt>size == capacity</tt> and <tt>low == high</tt></li>
</ul>

<h4>Increasing capacity</h4>
As with the <tt>ArrayList</tt>, we must deal with enlarging 
<tt>capacity</tt> 
when a new element is added to a full
<tt>ArrayDeque</tt>, i.e., 
when <tt>size == capacity</tt>.
The <tt>low</tt> index could conceivably be positioned anywhere within the new
array, and so the easiest thing to do is to copy the data from positions
<pre class='n'>
low, low+1, ..., high-1   <span class='ssf'>(using "mod capacity" arithmetic)</span>
</pre>
into positions <tt>0</tt> to <tt>capacity-1</tt> in the new array
and then reset
<pre class='n'>
low = 0
high = <span class="ssf">(the old)</span> capacity
</pre>


<h4>Alternative (textbook) implementation</h4>

In our implementation the <tt>high</tt> index always points to
the next <b>unused</b> position for an <tt>addLast</tt> operation.
This makes it possible to express 
an empty deque (or queue) with <tt>low == high</tt>.
Our textbook (as well as other authors) use a scheme whereby the
index postions always point at <b>used</b> positions. The author
refers to these positions as <tt>front</tt> and <tt>back</tt>. The
correspondence to my position pointers are roughly this:
<pre class="lh3 n">
front = low
back  = high - 1
</pre>
This the author's initial empty deque with capacity 40 would use:
<pre class="lh3 n">
front = 0
back  = 39  <span class="ssf">(i.e., <tt>-1</tt> in "circular" terms)</span>
</pre>
In general, the author's scheme would express both
<i>empty</i> and <i>full</i> as either:
<pre class='n'>
inc(back) == front    <span class="ssf">or</span>     back == dec(front)
</pre>
In my opinion, this form is more complicated than the inclusive/exclusive
scheme above.
Furthermore, the inclusive/exclusive index range is more
consistent with the Java API. 

<h3><a name="adeque"></a>ArrayDeque implementation (ADeque)</h3>

Create the Java (adapter) class:
<pre class='n'>
Class Name: <b>DequeAdapter</b>
package:    <b>adeque</b>
</pre>
Then insert the following content
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="ADequeDemo/src/adeque/DequeAdapter.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
adeque.DequeAdapter</span>
<a href="/~rkline/ds/showhide/target/deque-stack-algorithms">(click to show)</a>
</form>
<div></div>
</div>
</div>

Create the Java implementation class:
<pre class='n'>
Class Name: <b>ADeque</b>
package:    <b>adeque</b>
</pre>
Then insert the following content
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="ADequeDemo/src/adeque/ADeque.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
adeque.ADeque</span>
<a href="/~rkline/ds/showhide/target/deque-stack-algorithms">(click to show)</a>
</form>
<div></div>
</div>
</div>

<h4>Test programs</h4>
Add the <tt>import</tt> statement:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">import</span> <span class="co2">adeque.ADeque</span><span class="sy0">;</span></pre></div>
Then replace the <tt>ArrayDeque</tt> implementations
in "<tt>main1</tt>" as follows:

<div class='format_display'>
<span></span>
<pre class="java"><span class="co1">//Deque&lt;String&gt; stack = new ArrayDeque&lt;String&gt;();</span>
<span class="co1">//Queue&lt;String&gt; queue = new ArrayDeque&lt;String&gt;();</span>
&nbsp;
Deque<span class="sy0">&lt;</span>String<span class="sy0">&gt;</span> stack <span class="sy0">=</span> <span class="kw1">new</span> ADeque<span class="sy0">&lt;</span>String<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
Queue<span class="sy0">&lt;</span>String<span class="sy0">&gt;</span> queue <span class="sy0">=</span> <span class="kw1">new</span> ADeque<span class="sy0">&lt;</span>String<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div>


A second test program, <tt>main2</tt>, is illustrated by the
following code. It uses a non-standard member function, 
<tt>info</tt>, which is intended to reveal information about the
internal variables.


Change <tt>main</tt> to call <tt>main2</tt> instead of <tt>main1</tt>.

<div class='format_display'>
<button class="print_hide select_text"
style='position:absolute;top:10px;right:5px;width:100px;font-size:9pt'>Select Text</button>
<span></span>
<pre class="java">  <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> main2<span class="br0">&#40;</span><span class="kw3">String</span><span class="br0">&#91;</span><span class="br0">&#93;</span> args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    Deque<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span> D <span class="sy0">=</span> <span class="kw1">new</span> ADeque<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">5</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      D.<span class="me1">addFirst</span><span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="nu0">10</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      D.<span class="me1">addLast</span><span class="br0">&#40;</span>i<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span>D<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span> <span class="st0">&quot;--&gt; info: &quot;</span> <span class="sy0">+</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>ADeque<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">&#41;</span>D<span class="br0">&#41;</span>.<span class="me1">info</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">+</span> <span class="st0">&quot;<span class="es0">\n</span>&quot;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    D.<span class="me1">addLast</span><span class="br0">&#40;</span><span class="nu0">11</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span>D<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span> <span class="st0">&quot;--&gt; info: &quot;</span> <span class="sy0">+</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>ADeque<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">&#41;</span>D<span class="br0">&#41;</span>.<span class="me1">info</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">+</span> <span class="st0">&quot;<span class="es0">\n</span>&quot;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    D.<span class="me1">addFirst</span><span class="br0">&#40;</span><span class="nu0">12</span><span class="br0">&#41;</span><span class="sy0">;</span>
    D.<span class="me1">addFirst</span><span class="br0">&#40;</span><span class="nu0">13</span><span class="br0">&#41;</span><span class="sy0">;</span>
    D.<span class="me1">addLast</span><span class="br0">&#40;</span><span class="nu0">14</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span>D<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span> <span class="st0">&quot;--&gt; info: &quot;</span> <span class="sy0">+</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>ADeque<span class="sy0">&lt;</span>Integer<span class="sy0">&gt;</span><span class="br0">&#41;</span>D<span class="br0">&#41;</span>.<span class="me1">info</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">+</span> <span class="st0">&quot;<span class="es0">\n</span>&quot;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span></pre></div>


<h3><a name="stack-algorithms"></a>Stack Algorithms</h3>

To say that they are "stack-based" means that
the algorithms use a list with this restricted set of operations:
<ul class="notes">
<li><tt>boolean isEmpty()</tt></li>
<li><tt>void push(E e)</tt></li>
<li><tt>E pop()</tt></li>
<li><tt>E element()</tt></li>
</ul>
The <tt>push</tt>, <tt>pop</tt> and <tt>element</tt> operations
must all access the <b>same</b> end of a list, either first or last.  
Java uses the <b>first</b> end for these operations.
The other key point is that the operations must be constant-time,
<tt>O(1)</tt>.
These are the viable options for a stack in Java:
<ol class="notes">
<li>
An <tt>ArrayDeque</tt>:
<div class='format_display'>
<span></span>
<pre class="java">Deque<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span> stack <span class="sy0">=</span> <span class="kw1">new</span> ArrayDeque<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div>
Use the pre-existing operations: push, pop, element.

<li>
A <tt>LinkedList</tt> in "deque mode":
<div class='format_display'>
<span></span>
<pre class="java">Deque<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span> stack <span class="sy0">=</span> <span class="kw1">new</span> LinkedList<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div>
Use the pre-existing operations: push, pop, element.

<li>An <tt>ArrayList</tt> using the "last" end:
<div class='format_display'>
<span></span>
<pre class="java">List<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span> stack <span class="sy0">=</span> <span class="kw1">new</span> ArrayList<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div>
In this case the standard operations are not available because
<tt>ArrayList</tt> does not implement the <tt>Deque</tt> interface.
Furthermore, we cannot use either end of the list; instead we 
must use the "wrong" end to avoid linear-time operations! 
<pre class="lh3">
void push(E e) { stack.add(e); }
E pop() { return stack.remove(stack.size()-1); }
E element() { return stack.get(stack.size()-1); }
</pre>

</ol>

<h3><a name='arith-eval'></a>Arithmetic Expression Evaluation</h3>

This section illustrates two common stack-based algorithms for 
arithmetic expression manipulation:
<ol type="a" class="notes">
<li>
evaluating an arithmetic expression written in postfix form.
</li>
<li>
converting an infix expression to postfix form.
</li>
</ol>

Converting an infix expression (the usual form) to postfix means to
write the expression so that the operators come after the operands.
There are no parentheses in such expressions. For simplicity we'll
look at only the standard binary operators: 
<pre class='n'>
+, &#150;, *, /
</pre>

<h4>Postfix expression evaluation</h4>

In the postfix expression evaluation algorithm, 
the stack contains only numbers.
Here is a sketch of the algorithm:
<pre>
for each expression token:
  if the token is a number:
    push it
  else (the token is an operator, OP):
    second = pop();
    first = pop();
    compute: result = first OP second
    push the result on the stack

when there are no more tokens, pop the answer off the stack
</pre>
The arithmetic expressions <tt>4 - ( 2 - 3 )</tt> and <tt>4 - 2 - 3</tt> have
these respective postfix expressions  and evaluations:
<pre>
4 2 3 - -

token    stack
-----    -----
         []
  4      [4]
  2      [2, 4]
  3      [3, 2, 4]
  -      [-1, 4]
  -      [5]
 END     []    &rArr; answer = 5
</pre>
<pre>
4 2 - 3 -

token    stack
-----    -----
         []
  4      [4]
  2      [2, 4]
  -      [2]
  3      [3, 2]
  -      [-1]
 END     []    &rArr; answer = -1
</pre>
The arithmetic expression  
<tt>( 7 + 3 ) * ( 11 &#150; 4 * 2 )</tt> has the following
postfix form and evaluation:
<pre>
7 3 + 11 4 2 * &#150; *

token    stack
-----    -----
         []
  7      [7]
  3      [3, 7]
  +      [10]
  11     [11, 10]
  4      [4, 11, 10]
  2      [2, 4, 11, 10]
  *      [8, 11, 10]
  &#150;      [3, 10]
  *      [30]
 END     []    &rArr; answer = 30
</pre>

<h4>Infix to Postfix conversion</h4>

The infix-to-postfix conversion algorithm is more complicated.
It is extremely simple if all operators
have the same precedence (such as "<tt>+</tt>" and "<tt>&#150;</tt>") 
and there are no parentheses. 
Adding parentheses and operators of differing precedence introduces
complications.
<p>
The goal of the algorithm is to construct an output string which is the
equivalent postfix form of a given infix expression.
The stack will hold operators and left parentheses.
One key observation is that
the numbers stay in the same order as in the infix expression.
</p>
Here is a sketch of the algorithm:
<pre>
for each expression token:
  if the token is a number:
    add it to output
  else if the token is a left paren:
    push it
  else if the token is a right paren:
    pop and add to output all tokens on stack up to left paren
    pop the left paren, but don't add to output
  else if the token is an operator:
    if stack is empty or the top is a left paren:
       push it
    else if the stack top is a <b>lower</b> precedence operator:
       push it
    else
       pop and add to output all operators of <b>higher or equal</b> precedence 
       push it

when there are no more tokens,
  pop and add to output all remaining operators on stack
</pre>
Observe in the way numbers are handled that the numbers appear in
the same order as in the infix expression.
Here are some xamples:
<pre>
7 - 3 + 5 - 2

token   stack     output
-----   -----     ------
        []
  7               7
  -     [-]
  3               7 3
  +     [+]       7 3 -
  5               7 3 - 5
  -     [-]       7 3 - 5 +
  2               7 3 - 5 + 2
 END    []        7 3 - 5 + 2 -
</pre>
                   
<pre>
7 + ( 3 + 5 - 4 ) - 2

token    stack        output
-----    -----        ------
         []
  7                   7
  +      [+]
  (      [ (, +]
  3                   7 3
  +      [+, (, +]
  5                   7 3 5
  -      [-, (, +]    7 3 5 +
  4                   7 3 5 + 4
  )      [+]          7 3 5 + 4 -
  -      [-]          7 3 5 + 4 - +
  2                   7 3 5 + 4 - + 2
 END     []           7 3 5 + 4 - + 2 -
</pre>

<pre>
7 + 10 * 6 / 4

token   stack         output
-----   -----         ------
        []        
  7                   7
  +     [+]
  10                  7 10
  *     [*, +]
  6                   7 10 6
  /     [/, +]        7 10 6 *
  4                   7 10 6 * 4
 END    []            7 10 6 * 4 / +
</pre>

</div><!--content-->


<script type="text/javascript" src="/javascript/jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="/~rkline/js/init.js"></script>




<p></p>
<div style="font-size:80%;line-height:13px;padding-bottom:5px;">
<hr />
<span style='float:right'>&copy; Robert M. Kline</span>
<div class='print_hide'>
&nbsp;
<div>
</div>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
<title>Data Structures - Closed Hashing</title>
<link rel="stylesheet" type="text/css" href="/~rkline/css/basic.css" />
<link rel="stylesheet" type="text/css" href="/~rkline/css/init.css" />
<link href="/~rkline/images/favicon.ico" rel="shortcut icon" type="image/icon" />
<link href="/~rkline/css/java.css" media="all" rel="stylesheet" type="text/css" />
<style type="text/css" media="print">
/* override other settings to make print-friendly appearance */
body { padding: 10px 20px; }
.print_hide { display: none; }
div.print_only { display: block; }
#header { margin-top: 0px; height: 30px; }
#content { margin-top: 25px; }
</style>
</head>
<body>

<div id="header">
<h2 style='margin:0'>
Closed Hashing</h2>
<div id="mtime">last modified: Feb 8, 2013</div>

<div id="toggle_all" class='print_hide'>
<a href="#">
toggle show-hides
</a>
</div>



<div id="sections" class='print_hide'>
<select name="sections">
<option value="">--- select a section ---</option>
<option value="#closed-hash-delete">Deletion</option>
<option value="#implement-demo">Implementation and Demo</option>
</select>
</div>

</div>

<div id="content">

A <i>closed hashing</i> implementation is one in which the 
elements stay in the array rather than being placed in an auxiliary collision 
set, such as a linked list.  In this case, we would make 
our internal data elements be something like this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw4">int</span> capacity<span class="sy0">;</span>
<span class="kw1">private</span> <span class="kw4">float</span> loadFactor<span class="sy0">;</span>
<span class="kw1">private</span> <span class="kw4">int</span> size <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw1">private</span> E<span class="br0">&#91;</span><span class="br0">&#93;</span> data<span class="sy0">;</span>       <span class="co1">// array of Elements, not of &quot;collision chains&quot;</span></pre></div>
<p></p>
The implication of closed hashing is that collisions must be resolved by 
finding alternative array locations. These alternative locations
are obtained by "probing" a sequence of possible indices. Following
this probe sequence we look for the occurrence of our element or else
null, where encountering null means that we have reached the end of 
the sequences of possible locations and conclude that the element is
not in the hash table.

<h3>Probing techniques</h3>

There are three  standard alternatives for probing algorithms:
<i>linear</i>, <i>quadratic</i>, <i>double-hash</i>.

<h4>Linear probing</h4>
The simplest idea
is called linear probing. Upon collision, look for an alternative
position in the sequence of indices following the hashed index.
<pre class="n">
hash(obj) + 1
          + 2
          + 3
          + ... increase by adding 1, mod by capacity
</pre>

<h4>Clustering Effects</h4>

There are two so-called <i>clustering</i> effects that come about
from linear probing (our textbook doesn't discuss them):
<ol class="notes">
<li><i>primary</i> clustering:
when a key hashes into a probe path of <b>other</b> collisions, 
it follows the same path.
<li><i>secondary</i> clustering:
two or more colliding elements must follow the same probe path.
</ol>
If you consider the open hashing model, it does not have primary 
clustering, but it does have secondary clustering. 
So the term primary in some sense signifies "worse."

<h4>Quadratic probing</h4>

A technique which eliminates primary clustering is called 
quadratic probing in which the following 
sequence of alternative locations is explored on collision:
<pre class="n">
hash(obj) + 1 
          + 4  = 2<sup>2</sup>
          + 9  = 3<sup>2</sup>
          + 16 = 4<sup>2</sup>
          + ... increase by adding successive odd numbers, mod by capacity
</pre>
One issue which must be resolved is whether we will actually be able to
find an open slot with this method under reasonable circumstances.
A relatively easy number-theoretic result ensures that if the capacity is 
prime and the load is under 50%, then the probe sequence will succeed.

<h4>Double-hash probing</h4>

A technique which eliminates both primary and secondary
clustering is <i>double-hashing</i>.
The idea is to compute a second hash value of the element to be inserted.
<pre class="n">
a = hash2(obj)
</pre>
We want <tt>0 &lt; a &lt; capacity</tt>. 
Using this value, search this sequence of alternative locations:
<pre class="n">
hash(obj) + a
          + 2 * a
          + 3 * a
          + ....   increase by adding a, mod by capacity
</pre>
Because the "<tt>a</tt>" value is likely to differ for different
elements, different probe sequences are used even when elements
collide.
<p></p>
This second hash function needs to generate integers somewhere in the range
from 1 (not 0) to <tt>capacity - 1</tt>.
A likely choice might be:
<pre class='n'>
max = prime2
hash2(obj) = max - abs(obj.hashCode() % max)
</pre>
where <tt>prime2</tt> is the first prime "down from" capacity (which itself
is a prime). This is more-or-less the approach that the textbook uses.
Nevertheless, it is not really necessay that <tt>max</tt> be a prime. Our
approach is simpler:
<pre class='n'>
max = capacity - 2;
hash2(obj) = max - abs(obj.hashCode() % max)
</pre>
This choice makes <tt>max</tt> an odd number, but probably not a prime.
Nevertheless, if the load factor is maintained correctly, 
<tt>hash2</tt> will be called infrequently, 
making the chances of duplicating
the <tt>hash2</tt> values of colliding elements unlikely.

<h4>Return value of probe functions</h4>
When we search for an element or key in a map, it is useful to be able to indicate the final
index of the search. If the element was not found, this is where we would insert it,
if it is found, say in a map, then the index gives us access to the value which
can be altered. We can follow a logic similar to what happens in binary search (inverted),
interpreting non-negative values as "not found" and negative values as "found";
<ul class="notes">
<li>
if the return value, <tt>val</tt>, is <b>non-negative</b>, it indicates that 
the element was <b>not found</b>, and the position <tt>val</tt> marks the
end of the probe sequence for possible insertion.
</li>
<li>
if the return value, <tt>val</tt>, is <b>negative</b>, it indicates that
the element was <b>found</b> and <tt>-val-1</tt> is
the position where it is found.
</li>
</ul>

For example, here is how double-hash probe might be written:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw4">int</span> hash2<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> max <span class="sy0">=</span> capacity <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span>
  <span class="kw1">return</span> max <span class="sy0">-</span> <span class="kw3">Math</span>.<span class="me1">abs</span><span class="br0">&#40;</span>obj.<span class="me1">hashCode</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> max<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">private</span> <span class="kw4">int</span> double_hash_probe<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> pos <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw4">int</span> amt <span class="sy0">=</span> hash2<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span> <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> pos<span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="sy0">-</span><span class="br0">&#40;</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      pos <span class="sy0">=</span> <span class="br0">&#40;</span>pos <span class="sy0">+</span> amt<span class="br0">&#41;</span> <span class="sy0">%</span> capacity<span class="sy0">;</span>
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div>
The <tt>contains</tt> and <tt>add</tt> operations would look like this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw4">int</span> probe<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span> 
  <span class="kw1">return</span> double_hash_probe<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw4">boolean</span> contains<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> probe<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw4">boolean</span> add<span class="br0">&#40;</span>E elt<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> pos <span class="sy0">=</span> probe<span class="br0">&#40;</span>elt<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>pos <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span>
  <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
    <span class="sy0">++</span>size<span class="sy0">;</span>
    data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span> <span class="sy0">=</span> elt<span class="sy0">;</span>
    <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div>

<h4>Hash table load</h4>

Maintaining an acceptable load is even more critical in closed hashing than open hashing, because
there is an absolute limit on what can be put in the table, whereas with open hashing, we simply
would make the collision chains larger.


<h3><a name="closed-hash-delete"></a>Deletion</h3>

Removal of elements is tricky in closed hashing because
the removal of an element in the middle of a probe sequence would cause
the search for elements further on in the probe sequence to be "lost."
<p></p>
Given this limitation, deletion is best done by the so-called 
<i>lazy</i> deletion method in which 
a deleted element is simply <i>marked</i> as removed. The best way to mark
an object removed is to retain its value wrapped within a dedicated class
used for marking. One possibility is this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw1">class</span> Deleted<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span> <span class="br0">&#123;</span>
  E value<span class="sy0">;</span>
  Deleted<span class="br0">&#40;</span>E value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">value</span> <span class="sy0">=</span> value<span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="kw1">private</span> <span class="kw3">Object</span><span class="br0">&#91;</span><span class="br0">&#93;</span> data<span class="sy0">;</span>  <span class="co1">// data can now be of type E or Deleted&lt;E&gt;</span></pre></div>
Thus, removing an element means finding it at some position, <tt>pos</tt>, and then
simply setting:
<div class='format_display'>
<span></span>
<pre class="java">data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="kw1">new</span> Deleted<span class="br0">&#40;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div>
The hard part is figuring out precisely how to use these deleted markers. In particular,
when we are probing, say for the <tt>add</tt> operation
<div class='format_display'>
<span></span>
<pre class="java">add<span class="br0">&#40;</span>elt<span class="br0">&#41;</span><span class="sy0">;</span></pre></div>

we want this to happen:
<ul class="notes">
    <li>if we find <tt>elt</tt>, then nothing happens</li>
    <li>if we find <tt>Deleted(elt)</tt>, then it was already deleted so return the position
    where this was found so that <tt>elt</tt> can be effectively "undeleted"
    </li>
    <li>if we find some <tt>Deleted</tt> object, but not <tt>Deleted(elt)</tt>, then return the
    <b>first</b> position of a <tt>Deleted</tt> object in the probe path
    </li>
</ul>
In particular, a successful <tt>add</tt> operation will always reuse a deleted position if there is one
to avoid filling up the table with deleted elements.

It is programmatically quite tricky to achieve all these ends, and the <tt>double_hash_probe</tt> function
expands accordingly:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw4">int</span> double_hash_probe<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> pos <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw4">int</span> amt <span class="sy0">=</span> hash2<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw4">int</span> first_del_pos <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <span class="co1">// first deleted position marker</span>
&nbsp;
  <span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span> <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">// reached end of the probe path</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>first_del_pos <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> pos<span class="sy0">;</span>               <span class="co1">// no deleted elements discovered</span>
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> first_del_pos<span class="sy0">;</span>     <span class="co1">// found deleted element != obj</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> 
&nbsp;
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// obj found</span>
      <span class="kw1">return</span> <span class="sy0">-</span><span class="br0">&#40;</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span> 
&nbsp;
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span> <span class="kw1">instanceof</span> Deleted<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>Deleted<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span><span class="br0">&#41;</span>data<span class="br0">&#91;</span>pos<span class="br0">&#93;</span><span class="br0">&#41;</span>.<span class="me1">value</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">// prev. deleted</span>
        <span class="kw1">return</span> pos<span class="sy0">;</span>
      <span class="br0">&#125;</span> 
      <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>first_del_pos <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">// first deleted position unset</span>
        first_del_pos <span class="sy0">=</span> pos<span class="sy0">;</span>
      <span class="br0">&#125;</span>
      pos <span class="sy0">=</span> <span class="br0">&#40;</span>pos <span class="sy0">+</span> amt<span class="br0">&#41;</span> <span class="sy0">%</span> capacity<span class="sy0">;</span>    <span class="co1">// keep going</span>
    <span class="br0">&#125;</span> 
    <span class="kw1">else</span> <span class="br0">&#123;</span>                             <span class="co1">// obj not found</span>
      pos <span class="sy0">=</span> <span class="br0">&#40;</span>pos <span class="sy0">+</span> amt<span class="br0">&#41;</span> <span class="sy0">%</span> capacity<span class="sy0">;</span>
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div>
<p></p>
Note that the hash table should maintain information about the number of deleted elements as well
as <tt>size</tt> and combine these counts when computing the load, because deleted elements contribute
equally to filling up the table.


<h3><a name="implement-demo"></a>Implementation and Demo</h3>

The implementation is meant to be installed in the
<tt class='file'>HashDemo</tt> demo project. 
The implementation class is based on:

<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo/src/set/SetAdapter.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
set.SetAdapter</span>
<a href="/~rkline/ds/showhide/target/closed-hashing">(click to show)</a>
</form>
<div></div>
</div>
</div>
Create the class:

<pre class="n">
Class Name: <b>ClosedHashSet</b>
package:    <b>hash</b>
</pre>
Then insert the following content
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo/src/hash/ClosedHashSet.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
hash.ClosedHashSet</span>
<a href="/~rkline/ds/showhide/target/closed-hashing">(click to show)</a>
</form>
<div></div>
</div>
</div>

The <tt>ClosedHashSet</tt> class implements closed hashing with all
three probing versions possible.
Choose a probing version by setting the private data member:
<div class='format_display'>
<span></span>
<pre class="java">  <span class="kw1">private</span> <span class="kw3">String</span> whichProbe
    <span class="sy0">=</span> <span class="st0">&quot;linear&quot;</span>
  <span class="co1">//= &quot;quadratic&quot;</span>
  <span class="co1">//= &quot;double-hash&quot;</span>
    <span class="sy0">;</span></pre></div>
The following test function, <tt>mainClosedHashCompare</tt>, is manufactured to illustrate the clustering 
effects and thereby compare
the differences of the three probing methods.
It's assuming you already have the import:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">import</span> <span class="co2">hash.*</span><span class="sy0">;</span></pre></div>
To make the comparison, run it three times using each of the
three valid values of the private data member <tt>whichProbe</tt>.
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo_all/src/hashdemo/MainClosedHash.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
mainClosedHashCompare</span>
<a href="/~rkline/ds/showhide/target/closed-hashing">(click to show)</a>
</form>
<div></div>
</div>
</div>
Have <tt>main</tt> call it by:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">package</span> <span class="co2">whatever</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">set.SetAdapter</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">hash.ClosedHashSet</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw1">class</span> Whatever <span class="br0">&#123;</span>
&nbsp;
  <span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> main<span class="br0">&#40;</span><span class="kw3">String</span><span class="br0">&#91;</span><span class="br0">&#93;</span> args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">//...</span>
    mainClosedHashCompare<span class="br0">&#40;</span>args<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
&nbsp;
  <span class="kw1">static</span> <span class="kw4">void</span> mainClosedHashCompare<span class="br0">&#40;</span><span class="kw3">String</span><span class="br0">&#91;</span><span class="br0">&#93;</span> args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">//...</span>
  <span class="br0">&#125;</span>
&nbsp;
  <span class="co1">// ...</span>
<span class="br0">&#125;</span></pre></div>
</div><!--content-->


<script type="text/javascript" src="/javascript/jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="/~rkline/js/init.js"></script>




<p></p>
<div style="font-size:80%;line-height:13px;padding-bottom:5px;">
<hr />
<span style='float:right'>&copy; Robert M. Kline</span>
<div class='print_hide'>
&nbsp;
<div>
</div>

</body>
</html>
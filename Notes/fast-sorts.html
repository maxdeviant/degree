
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
<title>Data Structures - QuickSort &amp; MergeSort</title>
<link rel="stylesheet" type="text/css" href="css/basic.css" />
<link rel="stylesheet" type="text/css" href="css/init.css" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/icon" />
<link href="css/java.css" media="all" rel="stylesheet" type="text/css" />
<style type="text/css" media="print">
/* override other settings to make print-friendly appearance */
body { padding: 10px 20px; }
.print_hide { display: none; }
div.print_only { display: block; }
#header { margin-top: 0px; height: 30px; }
#content { margin-top: 25px; }
</style>
<style type="text/css" media="all">
<!--

table.mergesort {
 font-family: monospace;
}
table.mergesort td {
  border: solid 1px black;
  padding: 1px 2px 1px 2px;
}
table.mergesort td.name {
  border-width: 0px;
  padding-right: 5px;
}
table.mergesort td.special {
  border-width: 0px;
  font-family: sans-serif;
}
table.mergesort td.arrow {
  border-width: 0px;
  padding: 4px 0px 4px 0px;
}

table.q td {
  border: solid 1px black;
}
table.q tr.nb td {
  border-width: 0;
  padding-left: 3px;
}

-->
</style></head>
<body>

<div id="header">
<h2 style='margin:0'>
QuickSort &amp; MergeSort</h2>
<div id="mtime">last modified: Apr 15, 2013</div>

<div id="toggle_all" class='print_hide'>
<a href="#">
toggle show-hides
</a>
</div>



<div id="sections" class='print_hide'>
<select name="sections">
<option value="">--- select a section ---</option>
<option value="#quicksort">QuickSort</option>
<option value="#mergesort">MergeSort</option>
</select>
</div>

</div>

<div id="content">

You can create demos of both sorts discussed here using the 
<a href="user-defined-sorting.html#showsorts">mainShowSorts</a> 
function by simply setting the <tt>WHICH</tt> variable to 
the respective value and setting an appropriate array size <tt>NUM</tt>.
Timing and comparisons between these algorithms are useful. The 
<a href="shell-comparison.html#comparisons">mainTimeSorts</a> 
function is already set up to do this comparison.
Simply uncomment out appropriate code in each.


<h3><a name="quicksort"></a>QuickSort</h3>

The idea behind the quickSort algorithm is to choose, among the array 
elements, one which will serve as a <tt>pivot</tt> element used to split
the array into two parts:
<div class="n">
<table class="q" cellspacing="0">
<tr class='nb'>
<td></td>
<td><tt>i</tt></td>
</tr>
<tr align="center">
<td width="200px">&le; <tt>pivot</tt></td>
<td width="200px">&ge; <tt>pivot</tt></td>
</tr>
<tr class='nb'>
<td><tt>0</tt></td>
<td></td>
<td><tt>n</tt></td>
</tr>
</table>
</div>
The second phase calls quicksort recursively on the two parts.
We must ensure that the <tt>i</tt> index satisfies <tt>0 &lt; i &lt; n</tt>,
so that both parts are non-empty; otherwise,
quickSort could fall into infinite recursion!
The essence of quickSort's speed is to get the partitioning split to be as close as possible
to the middle. 
<h4>Quicksort partitioning algorithm</h4>
A key step is how the pivot is chosen. We do so by 
sorting the elements at three positions: 
<pre class='n'>
a[from], a[center], a[to-1]     ( center = (from+(to-1))/2 ) 
</pre>
The <tt>pivot</tt> is set to <tt>a[center]</tt> and
and the starting indices are as follows:
<div class="n">
<table> 
<tr> 
<td> 
a &nbsp;
<td> 
<table class="q" cellspacing="0">
<tr class='nb'>
<td align="center"><tt>i</tt></td>
<td></td>
<td align="center"><tt>j</tt></td>
</tr>
<tr align="center">
<td width="20px">&nbsp;</td>
<td width="300px">&nbsp;</td>
<td width="20px">&nbsp;</td>
</tr>
<tr class='nb'>
<td width="30px"><tt>from</tt></td>
<td></td>
<td width="30px" align=right><tt>to-1</tt></td>
<td ></td>
</tr>
</table>
</table>
</div>
By virtue of the sorting of the three elements, we know before the
loop starts that <tt>a[i] &le; pivot</tt> and <tt>pivot &le; a[j]</tt>.
Here is partition algorithm pseudo-code:
<div class='format_display'>
<span></span>
<pre class="java"><span class="co1">//sort the 3 elements { a[from], a[center], a[to-1] },  </span>
<span class="co1">//                      where center = (from + (to-1))/2</span>
pivot <span class="sy0">=</span> a<span class="br0">&#91;</span>center<span class="br0">&#93;</span>
i <span class="sy0">=</span> from
j <span class="sy0">=</span> to<span class="sy0">-</span><span class="nu0">1</span>
<span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw1">while</span> <span class="br0">&#40;</span>a<span class="br0">&#91;</span><span class="sy0">++</span>i<span class="br0">&#93;</span> <span class="sy0">&lt;</span> pivot<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="br0">&#125;</span>  <span class="co1">// move i up and keep going if element is &lt; pivot</span>
&nbsp;
   <span class="kw1">while</span> <span class="br0">&#40;</span>pivot <span class="sy0">&lt;</span> a<span class="br0">&#91;</span><span class="sy0">--</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="br0">&#125;</span>  <span class="co1">// move j down and keep going if element is &gt; pivot</span>
&nbsp;
   <span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy0">&lt;</span> j<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      swap<span class="br0">&#40;</span>a, i, j<span class="br0">&#41;</span><span class="sy0">;</span>
   <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      <span class="kw1">break</span><span class="sy0">;</span>
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div>

In the quickSort splitting code, 
the indices <tt>i</tt> and <tt>j</tt> control the splitting 
and the  
<tt>i</tt> index ends up being the correct marker so that:
<ul class="notes">
<li><tt>for k &lt; i: a[k] &le; pivot</tt></li>
<li><tt>for k &ge; i: a[k] &ge; pivot</tt></li>
</ul>

Key points are that:
<ul class='notes'>
<li>
the <tt>while</tt> loops always move <tt>i</tt> up and <tt>j</tt> down
by at least one every time.
</li>
<li>
<tt>i</tt> and <tt>j</tt> indices <b>stop</b> whenever the element seen
<b>equal</b> to the pivot. This seems unnecessary and inefficient; 
however, in reality, it makes it more likely that the splitting 
will be closer to optimal (equal halves).
</li>
</ul>
After the partitioning is complete, we call the algorithm recursively
on both sides:
<div class='format_display'>
<span></span>
<pre class="java">quickSort<span class="br0">&#40;</span>a, from, i<span class="br0">&#41;</span><span class="sy0">;</span>
quickSort<span class="br0">&#40;</span>a, i, to<span class="br0">&#41;</span><span class="sy0">;</span></pre></div>
The key points of the partitioning which ensure that
this actually works is that:
<pre class='n'>
from &lt; i &lt; to
</pre>
without this guarantee, one of the recursive calls would be empty
and the other would be to the entire array (possibly altered).
This is the initial importance of the seemingly  inefficient
"&lt;" comparison when comparing against the <tt>pivot</tt> element.


<h4>Median of 3</h4>
The usage of the <tt>medianOf3</tt> helper function attempts to determine
the best possible choice of <tt>pivot</tt> in constant time.
The closer these two parts are to being the same size, the
faster the algorithm will be.
The <tt>medianOf3</tt> function sorts the left, center, and right elements 
and then <tt>pivot</tt> is chosen to be the value of the center element.
In particular, in a common order pattern of being "nearly sorted," 
<tt>medianOf3</tt> is likely to choose a good pivot element.

<h4>Smaller subarrays first to minimize stack height</h4>
In order to keep the stack height (recursion height) minimal, it is important
to make the recursive call on the smaller sub-array first.
Thus the recusive calls in our final version look like this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy0">-</span> from <span class="sy0">&lt;=</span> to <span class="sy0">-</span> i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  quickSort<span class="br0">&#40;</span>a, from, i<span class="br0">&#41;</span><span class="sy0">;</span>
  quickSort<span class="br0">&#40;</span>a, i, to<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
  quickSort<span class="br0">&#40;</span>a, i, to<span class="br0">&#41;</span><span class="sy0">;</span>
  quickSort<span class="br0">&#40;</span>a, from, i<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
With this modification, the extra space usage (i.e., stack depth) 
is <tt><big><i>O</i></big>(log(n))</tt>.
Without this change, a worst-case scenario (see below) can cause an
<tt><big><i>O</i></big>(n)</tt> stack depth.
<p></p>
For demonstration purpose, we can ignore this code change.
It has no effect on the total running time because
all recursive calls must be made, regardless of the order
in which they are done.

<h4>CUTOFF value</h4>
The quickSort splitting method,
in its usage of the <tt>medianOf3</tt> operation, 
cannot be used for arrays of size 2. 
In fact, it turns out to be best to avoid the recursive calls 
down to an array which is "too small."
Optimized quickSort implementations impose a <tt>CUTOFF</tt> value 
whereby all arrays of size less than or equal to this 
will be sorted by an alternative method,
<tt>insertionSort</tt> being a good choice.

<p>
The optimal <tt>CUTOFF</tt> value can be empirically 
determined to be 9 or 10 
by executing a main function counting operations
which does counting for a range of possible values.
</p>

<h4>Quicksort Code</h4>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="MySorts_Demo/src/mysorts/QuickSortArrays.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
<span class='ssf'>Here is the quick sort code</span></span>
<a href="/~rkline/ds/showhide/target/fast-sorts">(click to show)</a>
</form>
<div></div>
</div>
<p></p>
My version represents a slight deviation from the textbook's version. 
My tests indicate that my version is slightly less costly than the 
textbook's version which does two extra swaps in order to make the 
right side have one less element.


<h4>Demonstrations</h4>
The <tt>mainShowSorts</tt> function is useful for giving demonstrations
of quickSort; simply set:
<pre class="n">
WHICH = ShowAlgorithms.QUICK
</pre>
The one algorithmic difference to keep in mind is that the
<tt>quickSort</tt> algorithm in <tt>sorts.ShowAlgorithms</tt> 
uses a default cutoff value of 5 for demonstration purposes, whereas the 
<tt>sorts.Algorithms</tt> version uses the optimal cutoff value of 10. 
<p></p>
You can demonstrate of the effectiveness of the quickSort's splitting method 
by altering the generated values in the test array, e.g., try these:
<pre class="n">
NUM = 20;
for (int i = 0; i &lt; A.length; ++i) {
   A[i] = 10 + r.nextInt(3 * NUM);       // random
//or,
   A[i] = 10 + i;                        // sorted
//or,
   A[i] = 10 + NUM - i;                  // reverse sorted
//or
   A[i] = 10;                            // all equal
}
</pre>
Here is an example with 11 elements where the quicksort cutoff is set
at 6 making only one partition occur:
<pre class='n'>
   0  1  2  3  4  5  6   7  8  9  10
   -  -  -  -  -  -  -   -  -  -  --
A=[1, 4, 6, 8, 5, 7, 10, 4, 1, 6, 6]  sort 3 elements at: 0, 5=(0+10)/2, 10
   ^              ^               ^ 
  [1, 4, 6, 8, 5, 6, 10, 4, 1, 6, 7]  mOf3: pivot = A[5] = 6

         i                     j     
  [1, 4, 6, 8, 5, 6, 10, 4, 1, 6, 7]  swap 6 &amp; 6 

            i               j       
  [1, 4, 6, 8, 5, 6, 10, 4, 1, 6, 7]  swap 8 &amp; 1

                  i      j           
  [1, 4, 6, 1, 5, 6, 10, 4, 8, 6, 7]  swap 6 &amp; 4

                  j  i             
=>[1, 4, 6, 1, 5, 4, 10, 6, 8, 6, 7]  j = 5 &le; i = 6
</pre>
<p></p>
Now, <tt>quickSort(0,6); quickSort(6,11);</tt>, 
both of which call <tt>insertionSort</tt>.


<h4>Best Time</h4>

Quicksort's best case time is <tt><i><big>O</big></i>(n*log n)</tt>.
The best case occurs when the split
separates the array into two "equal" halves. In this case the timing
function would satisfy a recurrence equation like this:
<pre class="n">
T(n) &le; 2 * T(n/2) + C * n    // C * n = time to split
</pre>
We can make a quick argument about this result following the book's lead:
<pre class="n lh3">
T(n)/n &le; 2 * T(n/2)/n + C
       = T(n/2) / (n/2)  +  C             ( make the 2 factor divide the divisor )
       &le; T(n/4) / (n/4)  +  C  +  C       ( replace n by n/2 in previous )
       ...
       &le; T(1) / 1  +  C  +  ... +  C      ( C repeated log(n) times )
T(n)/n &le; T(1) + C * log(n)
</pre>
Thus 
<pre class="n">
T(n) &le; T(1) * n  +  C * n * log(n) = <i><big>O</big></i>(n*log n)
</pre>

<h4>Average Time</h4>

The average time of quicksort is also 
<tt><i><big>O</big></i>(n*log n)</tt>. 
The math is a bit more involved (see the textbook). 
One important thing to point out is that the assumption in the book 
is that the partition index, <tt>i</tt>, is equally likely to be any position 
<tt>0 &lt; i &lt; n</tt>. 
This is definitely not true for the <tt>quickSort</tt> algorithm above
in which the median-of-three <tt>pivot</tt> makes it far more likely that 
the split occur towards the middle.
The mathematical analysis becomes 
very involved if one takes this optimized pivot choice into consideration.

<h4>Worst time</h4>

QuickSort's worst case time is quadratic, 
i.e., <tt><i><big>&Omega;</big></i>(n<sup>2</sup>)</tt>, 
which occurs when the
splitting consistently leaves up to, say, <tt>K</tt> elements in 
one portion or the other. 
In that case the timing would satisfy something like this:
<pre class="n">
T(n) &ge; T(n-K) + n   // the "n" term means split must "look at" every element
</pre>
These "worst-case" arrays are convoluted, but it is still
possible that they occur in practice.
Here is one example which you can plug in and test:
<pre class="n">
sorts.ShowAlgorithms.setQuicksortCutoff(2);
A = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
                    2, 5, 1, 6, 3, 7, 0, 8, 4, 9
};
</pre>
Plug this into the 
<a href="user-defined-sorting.html#showsorts"><tt>mainShowSorts</tt></a>  function
<b>after</b> the
"typical array generation" section, so that it overrides the
definition of <tt>A</tt> and replaces it by this new one.
<p></p>

Sorting with this array consistently leaves 
two equal elements in the right-side split all the way down to the cutoff.

<h4>Generalizable example which has quadratic time</h4>
Another example which is simpler to generalize to a family of
arrays of varying sizes (<tt>n = 32</tt> in this case) is this:
<pre class="n">
A = new Integer[] { 
   10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
   10, 18, 10, 19, 10, 20, 10, 21, 10, 22, 10, 23, 10, 24, 10, 25
};
</pre>
Again, test this out in the
<a href="user-defined-sorting.html#showsorts"><tt>mainShowSorts</tt></a>  function,
like the previous example. 
Once again, the splitting consistently 
leaves two equal elements in the right side, but, in this case,
only until the array is &frac12; its original size. 
Doing the math, we can say:
<pre class="n">
T(m) &ge; T(m-2) + m, m &ge; n/2, 
</pre>
and we prove that the run time for this series of examples is
 <tt><i><big>&Omega;</big></i>(n<sup>2</sup>)</tt>:
<pre class="n">
T(n) &ge; T(n-2) + n
     &ge; T(n-4) + (n-2) + n
     &ge; T(n/2-2) + n/2 + ... + (n-2) + n
     &ge; n/2 + ... + (n-2) + n            (at least n/4 terms, all &ge; n/2)
     &ge; n/2 + n/2 + ... + n/2            (n/4 times)
     = n<sup>2</sup>/8 
</pre>
The point to make is that these worst case arrays are 
rather convoluted and 
not representative of common patterns (nearly sorted, almost all equal, etc.)
Nevertheless, some users will argue that quadratic time behavior 
<b>can</b> actually occur in practice.

<h3><a name="mergesort"></a>MergeSort</h3>

The idea behind mergeSort is a simple application of recursion:
<pre class="lh3 n">
mergeSort(A) {
  if (A.length == 1) return;  // nothing to do
  split A into two equal halves: A = (A1, A2)
  mergeSort(A1)
  mergeSort(A2)
  // then, the merge step, where we actually doing something
  // by merging the two sorted halves back into the full array:
  A = merge(A1,A2)
}
</pre>
<h4>MergeSort vs QuickSort recursion</h4>
MergeSort exhibits <i>end order</i> or <i>bottom up</i>
recursion in that all the
significant actions take place <b>after</b> the recursive calls.
This means that the array is split all the way down to singletons
(of size 1) and that all actions take place on the way out of recursion.
<p></p>
In contrast, quickSort is exactly the opposite, namely <i>top down</i> 
recursion in the sense that the main action of partitioning is done 
<b>before</b> the recursive calls. 

<h4>Analysis</h4>
Let <tt>T(n)</tt> be the worst-case number of comparisons and 
data movements for an array (of size <tt>n</tt>), we see that for  
<tt>n &gt; 1</tt>, <tt>T(n)</tt> is made up of these counts:
<ol type="a" class="notes">
<li>recursive call on the two halves of <tt>A</tt>: <tt>2 * T(n/2)</tt></li>
<li>merge the halves of 
<tt>A</tt> (in a stable manner): <tt><i><big>O</big></i>(n)</tt></li>
</ol>
and conclude that:
<pre class="n">
T(n) = 2 * T(n/2) + <big><i>O</i></big>(n)
</pre>
We've seen this recurrence many times before and know the solution is
<tt><i><big>O</big></i>(n*log n)</tt>.
Thus the significance of mergeSort is that:
<ul class="notes">
<li>its <b>worst</b> case time is
<tt><i><big>O</big></i>(n*log n)</tt>.
<li>it is stable
</ul>

The one detraction of mergesort is that it requires a spare array in order
to do the merge operations; for a huge array, 
this may be considered too costly.
<p></p>
Our first inefficient approach is think of <tt>B</tt> as always
being the <i>merge target</i>.
<ol type="a" class="notes">
<li>If the size of <tt>A</tt> is 1, 
    copy <tt>A</tt> into <tt>B</tt>.
</li>
<li>If the size is greater than 1, 
call mergeSort 
recursively to sort left half of <tt>A</tt>, <tt>A1</tt>, 
into the left half of <tt>B</tt>, <tt>B1</tt>. Same with the right
half <tt>A2</tt> into <tt>B2</tt>.
</li>
<li> Copy <tt>B</tt> into <tt>A</tt>. <tt>A</tt> now consists
of two sorted halves. </li>
<li>
Merge the sorted halves <tt>(A1,A2)</tt> into <tt>B</tt>.
</li>
</ol>
At the completion of the algorithm, we would have to copy
<tt>B</tt>  back to <tt>A</tt>.

<h4>Efficient usage of merge target</h4>

A practical implementation of this algorithm does fewer data
movements than indicated above
by having 
<tt>A</tt>  and
<tt>B</tt> switch "roles" where one is the merge source and
the other the merge target.
In this way we completely avoid the copy step (b).
<p></p>
In any case, we want the final
merge target to be <tt>A</tt>. 
As we go into the recursion, the merge target alternates:
<pre class="n">
A &larr; B &larr; A &larr; B &larr; ... &larr; <span class="ssf">(base of recursion: <tt>A</tt> or <tt>B</tt>)</span>
</pre>
This requirement means that when we get to the base case 
with singleton arrays:
<ul class="notes">
<li>
if <tt>B</tt> is the merge target: copy (the single element) 
from <tt>A</tt> to <tt>B</tt>.
</li>
<li>
if <tt>A</tt> is the merge target: do nothing, the element is already in  
<tt>A</tt>.
</li>
</ul>

<hr />

<table class="mergesort">
<tr>
<td class="name">A&nbsp;=&nbsp;</td>
<td>17</td><td>16</td><td>15</td><td>14</td>
<td>13</td><td>12</td><td>11</td><td>10</td>
<td rowspan="3" class="name" 
    style="vertical-align:bottom;padding-left:20px;font-family:sans-serif">
(base of recursion)</td>
</tr>
<tr>
<td colspan="11"  class="arrow">&darr; (copy elements)</td>
</tr>

<tr>
<td class="name">B = </td>
<td>17</td><td>16</td><td>15</td><td>14</td>
<td>13</td><td>12</td><td>11</td><td>10</td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 1's to 2's)</td>
</tr>
<tr>
<td class="name">A&nbsp;=&nbsp;</td>
<td>16</td><td>17</td><td>14</td><td>15</td>
<td>12</td><td>13</td><td>10</td><td>11</td>
<td style="padding-left:20px;font-family:sans-serif;" class="name"><b>(sorted 2's)</b></td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 2's to 4's)</td>
</tr>
<tr>
<td class="name">B = </td>
<td>14</td><td>15</td><td>16</td><td>17</td>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td style="padding-left:20px;font-family:sans-serif;" class="name"><b>(sorted 4's)</b></td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 4's to 8's)</td>
</tr>
<tr>
<td class="name">A = </td>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td>14</td><td>15</td><td>16</td><td>17</td> 
<td style="padding-left:20px;font-family:sans-serif;" class="name"><b>THE GOAL (sorted 8's)</b></td>
</tr>
</table>

<hr />

<table class="mergesort">
<tr>
<td class="name">A&nbsp;=&nbsp;</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td>
<td>19</td><td>18</td>
<td>17</td><td>16</td>
<td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td>
<td rowspan="2" class="name" style="vertical-align:top;padding-left:20px;font-family:sans-serif">
(base of recursion &#151; do nothing)
</td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 1's to 2's)</td>
</tr>
<tr>
<td class="name">B = </td>
<td>24</td><td>25</td><td>22</td><td>23</td>
<td>20</td><td>21</td><td>18</td><td>19</td>
<td>16</td><td>17</td><td>14</td><td>15</td>
<td>12</td><td>13</td><td>10</td><td>11</td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 2's to 4's)</td>
</tr>
<tr>
<td class="name">A = </td>
<td>22</td><td>23</td><td>24</td><td>25</td>
<td>18</td><td>19</td><td>20</td><td>21</td>
<td>14</td><td>15</td><td>16</td><td>17</td>
<td>10</td><td>11</td><td>12</td><td>13</td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 4's to 8's)</td>
</tr>
<tr>
<td class="name">B = </td>
<td>18</td><td>19</td><td>20</td><td>21</td>
<td>22</td><td>23</td><td>24</td><td>25</td>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td>14</td><td>15</td><td>16</td><td>17</td>
</tr>
<tr>
<td colspan="100"  class="arrow">&darr; (merge 8's to 16's)</td>
</tr>
<tr>
<td class="name">A = </td>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td>14</td><td>15</td><td>16</td><td>17</td>
<td>18</td><td>19</td><td>20</td><td>21</td>
<td>22</td><td>23</td><td>24</td><td>25</td>
<td style="padding-left:20px;font-family:sans-serif" class="name"><b>THE GOAL</b></td>
</tr>
</table>


<h4>The MergeSort Code</h4>

In order to manage the merge target array, a 
boolean variable <tt>target_is_a</tt> is passed into
the recursive calls. This boolean indicates what to do
at the merge step:
<pre class="n lh3">
target_is_a = true:   <span class='ssf'><tt>A</tt> is the merge target, <tt>B</tt> is the source</span>
            = false:  <span class='ssf'><tt>B</tt> is the merge target, <tt>A</tt> is the source</span>
</pre>
The initial call assigns <tt>target_is_a</tt> to <tt>true</tt>,
indicating that we want the final merge to go into to the 
<tt>A</tt> array.
For each recursive step the boolean is <b>negated</b>, 
toggling between <tt>true</tt> and <tt>false</tt> 
all the way down to the base case of a single element.
<p></p>
When we get to the base case, a singleton array,
if <tt>target_is_a</tt> is <tt>true</tt>, i.e., the element must end up in 
<tt>A</tt>, then there is nothing to do because it is already there; 
otherwise the element must be copied from <tt>A</tt> into <tt>B</tt>.

<p></p>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="MySorts_Demo/src/mysorts/MergeSortArrays.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
<span class='ssf'>Here is the merge sort</span></span>
<a href="/~rkline/ds/showhide/target/fast-sorts">(click to show)</a>
</form>
<div></div>
</div>

<h4>Stability</h4>
In order to achieve stability, 
care must be taken in the merge operation;
<div class='format_display'>
<span></span>
<pre class="java">  <span class="kw1">private</span> <span class="kw1">static</span> <span class="sy0">&lt;</span>E<span class="sy0">&gt;</span> <span class="kw4">void</span> merge<span class="br0">&#40;</span>
    E<span class="br0">&#91;</span><span class="br0">&#93;</span> source, E<span class="br0">&#91;</span><span class="br0">&#93;</span> target, <span class="kw4">int</span> fromIndex, <span class="kw4">int</span> middle, <span class="kw4">int</span> toIndex,
    Comparator<span class="sy0">&lt;?</span> <span class="kw1">super</span> E<span class="sy0">&gt;</span> c<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
    <span class="kw4">int</span> i <span class="sy0">=</span> fromIndex, j <span class="sy0">=</span> middle, <span class="co1">// source indices in from array</span>
        k <span class="sy0">=</span> fromIndex<span class="sy0">;</span>             <span class="co1">// target index in to array</span>
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span>i <span class="sy0">&lt;</span> middle <span class="sy0">||</span> j <span class="sy0">&lt;</span> toIndex<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>i <span class="sy0">==</span> middle<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        target<span class="br0">&#91;</span>k<span class="sy0">++</span><span class="br0">&#93;</span> <span class="sy0">=</span> source<span class="br0">&#91;</span>j<span class="sy0">++</span><span class="br0">&#93;</span><span class="sy0">;</span>
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>j <span class="sy0">==</span> toIndex<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        target<span class="br0">&#91;</span>k<span class="sy0">++</span><span class="br0">&#93;</span> <span class="sy0">=</span> source<span class="br0">&#91;</span>i<span class="sy0">++</span><span class="br0">&#93;</span><span class="sy0">;</span>
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>c.<span class="me1">compare</span><span class="br0">&#40;</span>source<span class="br0">&#91;</span>i<span class="br0">&#93;</span>, source<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy0">&lt;=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// &quot;&lt;=&quot; gives stability</span>
          target<span class="br0">&#91;</span>k<span class="sy0">++</span><span class="br0">&#93;</span> <span class="sy0">=</span> source<span class="br0">&#91;</span>i<span class="sy0">++</span><span class="br0">&#93;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
          target<span class="br0">&#91;</span>k<span class="sy0">++</span><span class="br0">&#93;</span> <span class="sy0">=</span> source<span class="br0">&#91;</span>j<span class="sy0">++</span><span class="br0">&#93;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span></pre></div>

The left side of the merge is indexed by <tt>i</tt> and the right side by <tt>j</tt>.
Any equal elements in the sorted halves will be grouped together in correct order 
(this is an inductive assumption). If 
<tt>i</tt> and <tt>j</tt> are pointing to equal elements,
we ensure that the left-side element, i.e., the one with index <tt>i</tt>, 
goes into the target array first:
<div class='format_display'>
<span></span>
<pre class="java">  <span class="kw1">if</span> <span class="br0">&#40;</span>c.<span class="me1">compare</span><span class="br0">&#40;</span>from<span class="br0">&#91;</span>i<span class="br0">&#93;</span>,from<span class="br0">&#91;</span>j<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy0">&lt;=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">// NOT: &lt; 0 </span>
    to<span class="br0">&#91;</span>k<span class="sy0">++</span><span class="br0">&#93;</span> <span class="sy0">=</span> from<span class="br0">&#91;</span>i<span class="sy0">++</span><span class="br0">&#93;</span><span class="sy0">;</span></pre></div>

<h4>Best/worse case number of operations</h4>

MergeSort will always have the same number of data moves for 
arrays of equal sizes because the data is simply being
moved between source and target arrays for each of the "steps" of merge. 
In terms of comparisons, the best case
for a single merge is when the largest in one half is less
than or equal to the smallest in the other half, like this array of size 16:
<div class="n">
<table class="mergesort">
<tr>
<td class="name"></td>
<td>18</td><td>19</td><td>20</td><td>21</td>
<td>22</td><td>23</td><td>24</td><td>25</td>
<td style='background:#000'></td>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td>14</td><td>15</td><td>16</td><td>17</td>
</tr>
<tr>
<td colspan="100" class="name" style="padding:10px 0px 10px 100px">
&darr;
</td>
</tr>
<tr>
<td class="name"></td>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td>14</td><td>15</td><td>16</td><td>17</td>
<td style='background:#000'></td>
<td>18</td><td>19</td><td>20</td><td>21</td>
<td>22</td><td>23</td><td>24</td><td>25</td>
</tr>
</table>
</div>
With <tt>8</tt> comparisons, the "smaller" half (of size 8) goes 
first and then "larger" half fills out the array 
with no additional comparisons necessary.
Count roughly <tt>n/2</tt> comparisons for merging the
halves of an array of size <tt>n</tt>
<p></p>
The worst case is when the array elements are shuffled like this:
<div class="n">
<table class="mergesort">
<tr>
<td>10</td><td>12</td><td>14</td><td>16</td>
<td>18</td><td>20</td><td>22</td><td>24</td>
<td style='background:#000'></td>
<td>11</td><td>13</td><td>15</td><td>17</td>
<td>19</td><td>21</td><td>23</td><td>25</td>
</tr>
</table>
</div>
The shuffled structure will force comparisons between halves
for each of the 15 pairs.
Count roughly <tt>n-1</tt> comparisons to merge the halves on
an array of size <tt>n</tt>,
approximately twice as many comparisons as the best case.
<p></p>
Working our way down with this shuffling strategy,
 a worst case array of size 16 would be:
<div class="n">
<table class="mergesort">
<tr>
<td>10</td><td>18</td><td>14</td><td>22</td>
<td>12</td><td>20</td><td>16</td><td>24</td>
<td>11</td><td>19</td><td>15</td><td>23</td>
<td>13</td><td>21</td><td>17</td><td>25</td>
</tr>
<tr> <td class='special' colspan="100"> &#151; then proceeding with the sort &#151;</td> </tr>
<tr>
<td>10</td><td>18</td><td>14</td><td>22</td>
<td>12</td><td>20</td><td>16</td><td>24</td>
<td>11</td><td>19</td><td>15</td><td>23</td>
<td>13</td><td>21</td><td>17</td><td>25</td>
<td class='special'>
&nbsp;
&nbsp;
8 * 1 = 8 comparisons (but no changes)
</td>
</tr>
<tr>
<td>10</td><td>14</td><td>18</td><td>22</td>
<td>12</td><td>16</td><td>20</td><td>24</td>
<td>11</td><td>15</td><td>19</td><td>23</td>
<td>13</td><td>17</td><td>21</td><td>25</td>
<td class='special'>
&nbsp;
&nbsp;
4 * 3 = 12 comparisons
</td>
</tr>
<tr>
<td>10</td><td>12</td><td>14</td><td>16</td>
<td>18</td><td>20</td><td>22</td><td>24</td>
<td>11</td><td>13</td><td>15</td><td>17</td>
<td>19</td><td>21</td><td>23</td><td>25</td>
<td class='special'>
&nbsp;
&nbsp;
2 * 7 = 14 comparisons
</td>
</tr>
<tr>
<td>10</td><td>11</td><td>12</td><td>13</td>
<td>14</td><td>15</td><td>16</td><td>17</td>
<td>18</td><td>19</td><td>20</td><td>21</td>
<td>22</td><td>23</td><td>24</td><td>25</td>
<td class='special'>
&nbsp;
&nbsp;
15 comparisons
</td>
</tr>
</table>
</div>
</div><!--content-->


<script type="text/javascript" src="/javascript/jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="/~rkline/js/init.js"></script>




<p></p>
<div style="font-size:80%;line-height:13px;padding-bottom:5px;">
<hr />
<span style='float:right'>&copy; Robert M. Kline</span>
<div class='print_hide'>
&nbsp;
<div>
</div>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" /> 
<title>Data Structures - HashSets</title>
<link rel="stylesheet" type="text/css" href="css/basic.css" />
<link rel="stylesheet" type="text/css" href="css/init.css" />
<link href="images/favicon.ico" rel="shortcut icon" type="image/icon" />
<link href="css/java.css" media="all" rel="stylesheet" type="text/css" />
<style type="text/css" media="print">
/* override other settings to make print-friendly appearance */
body { padding: 10px 20px; }
.print_hide { display: none; }
div.print_only { display: block; }
#header { margin-top: 0px; height: 30px; }
#content { margin-top: 25px; }
</style>
<style type="text/css" media="all">
<!--

table.ph td {
    border-style: solid;
    border-color: black;
    border-width: 0px 1px 1px 1px;
    padding: 4px 6px;
}
table.ph tr:first-child td {
    border-top-width: 1px;
}
table.ph tr td:first-child {
    border-width: 0;
    text-align: right;
    padding-right: 5px;
}

-->
</style></head>
<body>

<div id="header">
<h2 style='margin:0'>
HashSets</h2>
<div id="mtime">last modified: Mar 24, 2013</div>

<div id="toggle_all" class='print_hide'>
<a href="#">
toggle show-hides
</a>
</div>



<div id="sections" class='print_hide'>
<select name="sections">
<option value="">--- select a section ---</option>
<option value="#discussion">Hashing concepts</option>
<option value="#demo">Demo Project</option>
<option value="#rehashing">Load and Rehashing</option>
<option value="#map-implementations">HashSet Implementation</option>
<option value="#linked-hash">LinkedHashSets</option>
</select>
</div>

</div>

<div id="content">

<h3><a name="discussion"></a>Hashing concepts</h3>

The na&iuml;ve idea of hashing is to store an element into
an array at a position <tt>index</tt> computed as follows:
<ul class="notes">
<li>
obtain <tt>element_hash_code</tt> of the element by
    processing the element's data and generating an integer value
(the idea of "hashing" the element roughly means "grinding it up")
</li>
<li>use a simple <i>mod</i> operation to map into the array's range:
<pre class="n">
index = hash(element) = abs(element_hash_code % array_capacity)
</pre>
The <tt>element_hash_code</tt> can be negative, and so the absolute value is needed to
ensure that we obtain a non-negative value.
</li>
</ul>
The obvious issue is that there may be two or more elements which
map to the same <tt>index</tt>; if so, we say there is a <i>collision</i>.
<p></p>
A hash function which produces no collisions for a set of elements
is referred to as <i>perfect</i> hash function for that set.
If we had a perfect hash function we could simply store the element
at that <tt>index</tt> position in the array, ignoring empty array positions.
The cost of searching for such an element would be no more than
the cost of computing the hash code for that element.
<p></p>
Here is a depiction of a "perfect" hash table of size 11.
<div class='n'>
<table><tr valign='top'>
<td style='padding-right:30px'>
Imagine the following set of strings and their<br />
computed hash values:
<pre class='n'>
element       hash(element)
-------       -------------
"beer"            5
"afterlife"       9
"wisdom"          4
"politics"        10
"schools"         1
"fear"            3
</pre>
The hash table would look like what you see here <span style='color:blue'>&rArr;</span>
<br />
</td>
<td>
<table class="ph" cellspacing=0 cellpadding=0>
<tr><td>0</td>
    <td>&nbsp</td>
</tr>
<tr><td>1</td>
    <td>"schools"</td>
</tr>
<tr><td>2</td>
    <td>&nbsp</td>
</tr>
<tr><td>3</td>
    <td>"fear"</td>
</tr>
<tr><td>4</td>
    <td>"wisdom"</td>
</tr>
<tr><td>5</td>
    <td>"beer"</td>
</tr>
<tr><td>6</td>
    <td>&nbsp</td>
</tr>
<tr><td>7</td>
    <td>&nbsp</td>
</tr>
<tr><td>8</td>
    <td>&nbsp</td>
</tr>
<tr><td>9</td>
    <td>"afterlife"</td>
</tr>
<tr><td>10</td>
    <td>"politics"</td>
</tr>
</table>
</td>
</tr></table>
</div>
The appearance of the following element would cause a collision:
<pre class='n'>
element       hash(element)
-------       -------------
"painting"        5
</pre>


<h4>Java's hashCode function</h4>

In order to do hashing, we must have access to, or
be able to create a suitable hash code for any element.
In a generic situation, this means that the element type
must be "hashable".
Fortunately, Java has a built-in, Object-level member
function called <tt>hashCode</tt>
which generates such a hash code for any element. 
You can try this simple example to view the <tt>hashCode</tt>
values of various element:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">for</span> <span class="br0">&#40;</span> <span class="kw3">Object</span> obj <span class="sy0">:</span> 
  <span class="kw1">new</span> <span class="kw3">Object</span><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span> <span class="st0">&quot;a&quot;</span>, <span class="st0">&quot;A&quot;</span>, <span class="kw1">new</span> <span class="kw3">Integer</span><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>, <span class="st0">&quot;a0&quot;</span>, <span class="st0">&quot;a1&quot;</span>, <span class="kw1">new</span> <span class="kw3">Float</span><span class="br0">&#40;</span><span class="nu0">10.0</span><span class="br0">&#41;</span> <span class="br0">&#125;</span> <span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
  <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span>obj.<span class="me1">hashCode</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
The output is:
<pre class='n'>
97
65
10
3055
3056
1092616192
</pre>
For a single character, the <tt>hashCode</tt> is the ASCII value, for
the Integer, the value itself, otherwise some function combines
the object's data bits to create the <tt>hashCode</tt>.
An important notion of hashing is that it is <i>replicable</i>,
i.e., the same element will generate the same hash code
every time the program is executed on any kind of system running Java,
for now and forever in the future. Amen!

<h4>Hashing is really not constant time, but we say it is</h4>

If we have no collisions, the search for a given string, would
simply involve computing the hash index and look in table at that 
index position.
Based on this idea, it is usually stated that the cost of a perfect
hash-based search is constant time, <tt><big>O</big>(1)</tt>,
or constant time, regardless of the number of elements.
<p></p>
The constant time claim is not technically correct.
The reason is that in order to have the ability to
create <tt>N</tt> distinct elements, each element must be constructed
from a finite set of symbols using a sequence of length
<tt><big><i>&Omega;</i></big>(log(N))</tt>. The hash function 
would have to process the entire symbol sequence in order
to avoid duplicating hash codes,
thus forcing an <tt><big><i>&Omega;</i></big>(log(N))</tt> lower bound
to compute the hash code.
<p></p>
Despite this technicality, hash search time 
(at least for perfect hashing) is
said to be <tt><big>O</big>(1)</tt>, or constant time.


<h4>Open hashing, chaining</h4> 

The key issue in hashing is dealing with, or <em>resolving</em>, collisions.
The simplest idea of resolving collisions is to group them together
as a set of colliding elements accessed through the array at the
hash index.
The technique called
<i>open</i> hashing (as opposed to <i>closed</i>) maintains the
set of colliding elements in a separate data structure called a <i>bucket</i>
accessed through the array index.
<p></p>
A hash search procedure becomes this operation:
<ul class='notes'>
<li>compute the hash index: &nbsp; <tt>index = abs(element.hashCode() % array_size)</tt>
<li>search the set <tt>bucket[index]</tt> for an occurrence of the element
</li>
</ul>
If all goes well with respect to the hashing operation, 
the buckets will be of a small size.
The easiest way to manage them is using a simple linked list.
Open hashing managed in this way is called <i>chaining</i>.
<p></p>

Consider this code segment:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw4">int</span> capacity <span class="sy0">=</span> <span class="nu0">11</span><span class="sy0">;</span>
<span class="kw3">String</span><span class="br0">&#91;</span><span class="br0">&#93;</span> strings <span class="sy0">=</span> <span class="br0">&#123;</span><span class="st0">&quot;music&quot;</span>, <span class="st0">&quot;beer&quot;</span>, <span class="st0">&quot;afterlife&quot;</span>, <span class="st0">&quot;wisdom&quot;</span>,
                    <span class="st0">&quot;politics&quot;</span>, <span class="st0">&quot;theater&quot;</span>, <span class="st0">&quot;schools&quot;</span>, <span class="st0">&quot;painting&quot;</span>, <span class="st0">&quot;fear&quot;</span><span class="br0">&#125;</span><span class="sy0">;</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw3">String</span> s <span class="sy0">:</span> strings<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">&#40;</span>
    <span class="st0">'&quot;'</span> <span class="sy0">+</span> s <span class="sy0">+</span> <span class="st0">'&quot;'</span> 
        <span class="sy0">+</span> <span class="st0">&quot;<span class="es0">\n</span><span class="es0">\t</span>hash code: &quot;</span> <span class="sy0">+</span> s.<span class="me1">hashCode</span><span class="br0">&#40;</span><span class="br0">&#41;</span> 
        <span class="sy0">+</span> <span class="st0">&quot;<span class="es0">\n</span><span class="es0">\t</span>array index: &quot;</span> <span class="sy0">+</span> <span class="kw3">Math</span>.<span class="me1">abs</span><span class="br0">&#40;</span>s.<span class="me1">hashCode</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> capacity<span class="br0">&#41;</span>
  <span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
The output is is for an array of capacity 11 with 9 string elements. The
following depicts the execution of this code and
the appearance of the desired hash table:
<table><tr>
<td>
<pre class='n'>
"music"
    hash code: 104263205
    array index: 2
"beer"
    hash code: 3019824
    array index: 5
"afterlife"
    hash code: 1019963096
    array index: 9
"wisdom"
    hash code: -787603007
    array index: 4
"politics"
    hash code: 547400545
    array index: 10
"theater"
    hash code: -1350043631
    array index: 2
"schools"
    hash code: 1917457279
    array index: 1
"painting"
    hash code: 925981380
    array index: 5
"fear"
    hash code: 3138864
    array index: 3
</pre> 
</td>
<td>
<img src="images/chaining.gif" />
</td>
</tr></table>
In particular we see that with 9 strings out of 11 indices we
 have only two collisions making the buckets at indices 2 and 5 
 each of size 2. This gives us the right sense about how well hashing can perform.
Note that the order within the chains is not the entry order.
Hashing per se need not make any attempt to keep track of the order of
elements in any way.


<h4>Array capacity</h4> 

Our example uses an array of capacity 11.
The textbook chooses a default capacity of 101.  Why 11 and 101 and not 10 and 100?
The reason is that we want the capacity to be
 a <b>prime</b> number.  What is important about being a prime? 
The reason is that it makes the <i>mod</i> operation less "predictable". 
<p></p>
For example, suppose we had a table whose <tt>capacity</tt> was <b>even</b>
and we want to put these Integer keys (whose <tt>.hashCode</tt> is the value)
into the table:
<pre class='n'>
key = 39934, 9656, 73232, 8856, 2342342, 3003338
</pre>
The target index in each case would be:
<pre class='n'>
index = key % capacity
</pre>
What can we say about <tt>index</tt>? It is even. Thus the even <tt>capacity</tt>
makes the resultant indices "predictable". So we should not allow an even capacity.
The same can be said for a capacity value which is the multiple of some other small
value.
The rule of thumb is that the capacity should be either
a prime or else the product of "large" primes.



<h3><a name="demo"></a>Demo Project</h3>

Create a NetBeans project <tt class='file'>HashDemo</tt>. 
Assuming you use the default setup of NetBeans, the main class will be
named <tt>HashDemo</tt>.
Change the content to the following:

<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo/src/hashdemo/HashDemo.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
hashdemo.HashDemo</span>
<a href="/~rkline/ds/showhide/target/hash-sets">(click to show)</a>
</form>
<div></div>
</div>
</div>

Initially there are three demo programs to test:

<ol class="notes">
<li><b><tt>mainShowHashValues</tt></b>: shows the hash codes and
index values for various
elements
</li>
    
    
<li><b><tt>mainShowSets</tt></b>:
Compare <tt>TreeSet</tt>, <tt>HashSet</tt>, and 
<tt>LinkedHashSet</tt> in terms of retrieval of stored elements.
</li>

<li><b><tt>mainCompareTreeHashSets</tt></b>:
Create a sorted list of unique random integers from a list possibly
containing duplicates. 
This program makes the timing comparison between:
<ul class="notes">
<li>Entering numbers into a <tt>HashSet</tt>,
transferring the set to a list, and sorting
the list.
</li>
<li>
Entering numbers into a <tt>TreeSet</tt>,
transferring to a list (since it's already sorted).
</li>
</ul>
Our code does this operation twice and the second time is the one 
that "counts."
</li>

</ol>

<h3><a name="rehashing"></a>Load and Rehashing</h3>

Assuming that the hash code computation is constant time, the lookup
time now involves comparisons against elements in the collision chain and so
it is critical importance to somehow ensure that the buckets remain
of a small size.
<p></p>
The crucial measure of performance of a hash table is the <i>load</i>,
which is simply:
<div class='n'>
<tt>load</tt> = (# elements in the hash table) / <tt>capacity</tt>
</div>
If the load becomes too large, the buckets, obviously, can
become too large and cause degradation of the search time.
For example, this hash table in the above example has a load of
<pre class='n'>
9/11 = .82
</pre>
The hash table implementation must establish a maximum allowable load value
which Java refers to as the <i>load factor</i>.
According to Java documentation, a load factor of <tt>.75</tt> is recommended.
For example,
the table in our previous example has a load (<tt>.82</tt>) greater than
the acceptable value. 

<h4>Rehash</h4>

When the load becomes greater than the allowable load factor, a
<i>rehash</i> operation is required. The operation is similar to what is done
with the <tt>ArrayList</tt> class in that we put the same content into 
a larger array. It goes like this:
<ol type="a" class="notes">
<li>
Find a suitable larger <tt>capacity</tt> &ge; twice the previous capacity. 
We will assume <tt>capacity</tt> is always a prime numbers, 
meaning we have to find a prime
number bigger than the current value of <tt>2 * capacity</tt>.
</li>
<li>Allocate a new array using the increased <tt>capacity</tt> value.</li>

<li>Traverse the old hash table. For each data element,
compute a new index value (the hash <b>code</b> is the same, but the target
<b>index</b>, subject to mod by a new <tt>capacity</tt> value,
will most likely have changed), then
reinsert the element into the new table.</li>
</ol>
As in the case of the <tt>ArrayList</tt>, we want to ensure that the average
cost of adding an element is still <tt><big><i>O</i></big>(1)</tt>, 
which will be true so long as the cost of each rehash is 
<tt><big><i>O</i></big>(N)</tt>. 
The only feature that is significantly different from the situation 
of the <tt>ArrayList</tt> is that the capacities must be primes, 
an issue which must be explored a bit.

<h4>Finding the next prime</h4>

The Java function used by our implementation to calculate the next larger
prime is the function <tt>primeUp(n)</tt>. 
The idea is to use a nested loop where the <b>outer</b> loop 
examines all odd numbers <tt>&ge; n</tt> and 
the <b>inner</b> loop sees if we can find reject it
by finding an odd divisor between 3 and its square root; the first
number which cannot be rejected is the prime we want.
 
Here is the definition of the <tt>primeUp</tt> function:

<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw4">int</span> primeUp<span class="br0">&#40;</span><span class="kw4">int</span> n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> prime <span class="sy0">=</span> n<span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>prime <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    prime <span class="sy0">+=</span> <span class="nu0">1</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
  <span class="co1">// start the test loop with prime = first odd number up from n</span>
  <span class="kw4">boolean</span> found_prime<span class="sy0">;</span>
  <span class="kw1">do</span> <span class="br0">&#123;</span>                       <span class="co1">// outer loop, testing odd numbers &amp;ge; n</span>
    found_prime <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
    <span class="co1">// check for divisibility for all odd numbers between 3 and sqrt(prime)</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> <span class="kw3">Math</span>.<span class="me1">sqrt</span><span class="br0">&#40;</span>prime<span class="br0">&#41;</span><span class="sy0">;</span> i <span class="sy0">+=</span> <span class="nu0">2</span><span class="br0">&#41;</span> 
    <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>prime <span class="sy0">%</span> i <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        found_prime <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
        prime <span class="sy0">+=</span> <span class="nu0">2</span><span class="sy0">;</span>          <span class="co1">// divisor found, reject this one and</span>
        <span class="kw1">break</span><span class="sy0">;</span>               <span class="co1">// try the next odd number up</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span> <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>found_prime<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
  <span class="kw1">return</span> prime<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>

In our implementations of hashed structures, 
the rehash operation will increase <tt>capacity</tt> with the call:
<pre class="n">
new_capacity = primeUp( 2 * capacity + 1 );
</pre>
i.e., the call to 
<tt>primeUp</tt>
uses the value
<pre class="n">
n = 2 * capacity + 1
</pre>
as the starting point in searching for the next prime.
The question is how many outer loops will execute, 
i.e., how far from <tt>n</tt> must we go to find the next prime?
We can use the result from the famous 
<a target="_reference" 
   href="http://en.wikipedia.org/wiki/Prime_number_theorem"
   >Prime Number Theorem</a>
which states 
<blockquote>
the number of primes &le; <tt>n</tt> is approximately <tt>ln(n)/n</tt> 
(using the natural logarithm).
</blockquote>
We can infer that, on the average,
the next prime will be found after <tt>ln(n)</tt> outer loops.
The inner loop executes at most <tt>sqrt(n)/2</tt> times (the number of odd
divisors which are tested).
<p></p>
Assume that the rehash is called when the number of elements, 
<tt>N &ge; .75 * capacity</tt>.
We can then compute the average time (counting integer divisions)
to find a the next prime in terms of the number, 
<tt>N</tt>, of elements to be:
<pre class="n lh3">
&le; ln( 2*capacity + 1 ) * sqrt( 2*capacity + 1 ) / 2
&le; ln(2*N/.75 + 1) * sqrt(2*N/.75 + 1) / 2
= <big><i>O</i></big>( log(N) * sqrt(N) ) 
= <i>o</i>( sqrt(N) * sqrt(N) )   <span class="ssf">since</span> log(N) = o(sqrt(N))
= <i>o</i>(N)
</pre>
Since a rehash costs <tt><big>O</big>(N)</tt> 
just to move the <tt>N</tt> elements
into the new hash table, we conclude that the <tt>primeUp</tt> function 
adds no significant extra cost.


<h3><a name="map-implementations"></a>HashSet Implementation</h3>

Our user-defined <tt>OpenHashSet</tt> class extends the
<tt>SetAdapter</tt> class which was used as the basis of the
<tt>SearchTree</tt> class in the
<a href="search-trees.html">TreeSets</a> document.
Either copy from the <tt>TreeDemo</tt> project, or
create the Java Class fresh:
<pre class='n'>
Class Name: <b>SetAdapter</b>
package:    <b>set</b>
</pre>
Then insert the following content
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo/src/set/SetAdapter.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
set.SetAdapter</span>
<a href="/~rkline/ds/showhide/target/hash-sets">(click to show)</a>
</form>
<div></div>
</div>
</div>
Our implementation class is this:
<pre class='n'>
Class Name: <b>OpenHashSet</b>
package:    <b>hash</b>
</pre>
with the following content:
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo/src/hash/OpenHashSet.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
hash.OpenHashSet</span>
<a href="/~rkline/ds/showhide/target/hash-sets">(click to show)</a>
</form>
<div></div>
</div>
</div>

<h4>Demo function</h4>

Use the <tt>HashDemo</tt> main class. Add (uncomment) the <tt>import</tt> statement:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">import</span> <span class="co2">hash.*</span><span class="sy0">;</span></pre></div>
then add this alternative main function:
<div class='n'>
<div class='file_display show_hide'>
<form action="#">
<input type='hidden' name='path' value="HashDemo_all/src/hashdemo/mainTestOpenHashSet.java" />
<input type='hidden' name='lang' value="java" />
<input type='hidden' name='status' value="0" />
<input type='hidden' name='can_select' value="1" />
<span class='show_hide_label'>
mainTestOpenHashSet</span>
<a href="/~rkline/ds/showhide/target/hash-sets">(click to show)</a>
</form>
<div></div>
</div>
</div>
Activate it by having the <tt>main</tt> function call it:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> main<span class="br0">&#40;</span><span class="kw3">String</span><span class="br0">&#91;</span><span class="br0">&#93;</span> args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  mainTestOpenHashSet<span class="br0">&#40;</span>args<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>


<h4>Basis</h4>

At the basis of the <tt>OpenHashSet</tt> are the <tt>Node</tt> class and data elements:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw1">class</span> Node<span class="sy0">&lt;</span>E<span class="sy0">&gt;</span> <span class="br0">&#123;</span>
  E data<span class="sy0">;</span>
  Node next<span class="sy0">;</span>
  Node<span class="br0">&#40;</span>E data, Node next<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">data</span> <span class="sy0">=</span> data<span class="sy0">;</span>
    <span class="kw1">this</span>.<span class="me1">next</span> <span class="sy0">=</span> next<span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">private</span> Node<span class="br0">&#91;</span><span class="br0">&#93;</span> bucket<span class="sy0">;</span>
<span class="kw1">private</span> <span class="kw4">int</span> capacity<span class="sy0">;</span>      <span class="co1">// default value 101</span>
<span class="kw1">private</span> <span class="kw4">float</span> loadFactor<span class="sy0">;</span>  <span class="co1">// default value .75</span>
<span class="kw1">private</span> <span class="kw4">int</span> size <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span></pre></div>
Both the <tt>capacity</tt> and the <tt>loadFactor</tt> 
can be set through the constructor:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">public</span> OpenHashSet<span class="br0">&#40;</span><span class="kw4">int</span> capacity, <span class="kw4">float</span> loadFactor<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  capacity <span class="sy0">=</span> primeUp<span class="br0">&#40;</span>capacity<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// we need a prime</span>
  <span class="kw1">this</span>.<span class="me1">capacity</span> <span class="sy0">=</span> capacity<span class="sy0">;</span>
  bucket <span class="sy0">=</span> <span class="kw1">new</span> Node<span class="br0">&#91;</span>capacity<span class="br0">&#93;</span><span class="sy0">;</span>
  <span class="kw1">this</span>.<span class="me1">loadFactor</span> <span class="sy0">=</span> loadFactor<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>

<h4>Dealing with null</h4>

Unlike <tt>TreeSet</tt>s, Java <tt>HashSet</tt>s and <tt>LinkedHashSet</tt>s permit <tt>null</tt> to be in the set.
The problem is that
<tt>null</tt> must to be treated as an exceptional case, because <tt>hash(null)</tt> cannot be computed
and the equality tests will fail as written.
For simplicity, our implementation will <b>disallow</b> the <tt>null</tt> value
by initially testing each operation with something like this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">if</span> <span class="br0">&#40;</span>obj <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw1">throw</span> <span class="kw1">new</span> java.<span class="me1">lang</span>.<span class="kw3">IllegalArgumentException</span><span class="br0">&#40;</span><span class="st0">&quot;null not allowed&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
Our operations do not show this preliminary code.

<h4>Contains, add and remove</h4>

The key idea in hashing-based operations is that every operation begins, either explicitly or implicitly,
with code like this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw4">int</span> index <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>           <span class="co1">// find the hash index of the element</span>
Node n <span class="sy0">=</span> bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span><span class="sy0">;</span>   <span class="co1">// access the Node chain for that index</span></pre></div>
For example, the <tt>contains</tt> function (in interative form) is:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">public</span> <span class="kw4">boolean</span> contains<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> index <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  Node n <span class="sy0">=</span> bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span><span class="sy0">;</span>
  <span class="kw1">while</span> <span class="br0">&#40;</span>n <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>n.<span class="me1">data</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    n <span class="sy0">=</span> n.<span class="me1">next</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
  <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
The <tt>add</tt> operation can rely on <tt>contains</tt>. We have to deal with the possibility of doing
a rehash if the new <tt>size</tt> would push beyond the allowable <tt>loadFactor</tt>, in which
case the hash value must be recomputed. When an element is added it is irrelevant where it is added
within the node chain, and so our implementation effects an "<tt>addFirst</tt>" operation to the node chain.
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">public</span> <span class="kw4">boolean</span> add<span class="br0">&#40;</span>E elt<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>contains<span class="br0">&#40;</span>elt<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
  <span class="sy0">++</span>size<span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span>size<span class="sy0">/</span>capacity <span class="sy0">&gt;</span> loadFactor <span class="br0">&#41;</span> <span class="br0">&#123;</span>
    rehash<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
  <span class="kw4">int</span> index <span class="sy0">=</span> hash<span class="br0">&#40;</span>elt<span class="br0">&#41;</span><span class="sy0">;</span>
  bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="kw1">new</span> Node<span class="br0">&#40;</span>elt, bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
For the <tt>remove</tt> operation, if necessary we remove the element from 
the node chain using a private recursive helper written in the style used 
for operations in <tt>SearchTreeSet</tt>; i.e., the head of the node chain 
is treated as a reference parameter.
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">public</span> <span class="kw4">boolean</span> remove<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>contains<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> 
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
  <span class="sy0">--</span>size<span class="sy0">;</span>
  <span class="kw4">int</span> num <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  bucket<span class="br0">&#91;</span>num<span class="br0">&#93;</span> <span class="sy0">=</span> remove<span class="br0">&#40;</span>bucket<span class="br0">&#91;</span>num<span class="br0">&#93;</span>, obj<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">private</span> Node remove<span class="br0">&#40;</span>Node n, <span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>n.<span class="me1">data</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> n.<span class="me1">next</span><span class="sy0">;</span>
  <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
    n.<span class="me1">next</span> <span class="sy0">=</span> remove<span class="br0">&#40;</span>n.<span class="me1">next</span>,obj<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">return</span> n<span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div>
An alternative iterative version attempts to position the pointer prior
to the node containing the element. It must deal with a singleton list as
a special (and most common) case:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">public</span> <span class="kw4">boolean</span> remove<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>contains<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> 
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span>
  <span class="br0">&#125;</span>
  <span class="sy0">--</span>size<span class="sy0">;</span>
  <span class="kw4">int</span> num <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>bucket<span class="br0">&#91;</span>num<span class="br0">&#93;</span>.<span class="me1">next</span> <span class="sy0">==</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// one node only which must contain obj</span>
    bucket<span class="br0">&#91;</span>num<span class="br0">&#93;</span>.<span class="me1">next</span> <span class="sy0">=</span> <span class="kw2">null</span><span class="sy0">;</span>      <span class="co1">// clear the singleton chain</span>
  <span class="br0">&#125;</span> 
  <span class="kw1">else</span> <span class="br0">&#123;</span>
    Node n <span class="sy0">=</span> bucket<span class="br0">&#91;</span>num<span class="br0">&#93;</span><span class="sy0">;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>n.<span class="me1">next</span>.<span class="me1">data</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      n <span class="sy0">=</span> n.<span class="me1">next</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    <span class="co1">// n.next hold obj</span>
    n.<span class="me1">next</span> <span class="sy0">=</span> n.<span class="me1">next</span>.<span class="me1">next</span><span class="sy0">;</span>  <span class="co1">// reroute around n.next which contains obj</span>
  <span class="br0">&#125;</span>
  <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>

<h4>Timing</h4>

The <tt>contains</tt>, <tt>add</tt>, and <tt>remove</tt> operations are 
all considered to be constant time, or <tt><big>O</big>(1)</tt> operations.


<h3><a name="linked-hash"></a>LinkedHashSets</h3>

The Java <tt>LinkedHashSet</tt> object, as we have seen in the demo program, keeps track
of the entry order of elements yet retains its contant time speed for the lookup-based operations.
The way to achieve this effect is to maintain, in addition to the hash table, a linked list
which holds the elements. The linked list is used exclusively for <b>iteration</b> through the elements.
<p></p>
As an example, we'll revisit the hash entries into a table of capacity 11:
<pre class='n'>
element       index
-------       -----
"music"         2
"beer"          5
"afterlife"     9
"wisdom"        4
"politics"      10
"theater"       2
"schools"       1
"painting"      5
"fear"          3
</pre>
Here is a depiction of the underlying structure:
<div class='n'>
<img src="images/linked-hashset.gif" width="600px" height="420px" />
</div>
What is being suggested is the following additions/modifications to the node structure:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> <span class="kw1">class</span> Node <span class="br0">&#123;</span>
  ListNode ptr<span class="sy0">;</span>
  Node next<span class="sy0">;</span>
  Node<span class="br0">&#40;</span>ListNode ptr, Node next<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">ptr</span> <span class="sy0">=</span> ptr<span class="sy0">;</span>
    <span class="kw1">this</span>.<span class="me1">next</span> <span class="sy0">=</span> next<span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">private</span> <span class="kw1">class</span> ListNode <span class="br0">&#123;</span>
  E data<span class="sy0">;</span>
  ListNode next<span class="sy0">;</span>
  ListNode prev<span class="sy0">;</span>
  ListNode<span class="br0">&#40;</span>E data, ListNode next, ListNode prev<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">data</span> <span class="sy0">=</span> data<span class="sy0">;</span>
    <span class="kw1">this</span>.<span class="me1">next</span> <span class="sy0">=</span> next<span class="sy0">;</span>
    <span class="kw1">this</span>.<span class="me1">prev</span> <span class="sy0">=</span> prev<span class="sy0">;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">private</span> ListNode first, last<span class="sy0">;</span></pre></div>
In particular, the newly create <tt>ListNode</tt> inner class is used for the doubly linked list which
maintains the entry order of elements. Within the hash table, the <tt>Node</tt> class has been modified
so that the <tt>ptr</tt> field is a pointer to the <tt>ListNode</tt> which contains the actual data.
What the letters A, B, C, etc., are suggesting are pointers within the <tt>Node</tt>
elements to the appropriate <tt>ListNode</tt> element, e.g., like this entry for <tt>"schools"</tt>:
<div class="n">
<img src="images/linked-hash-sample.png" />    
</div>
Without going into details, here is an outline of the operations:
<ol class='notes'>
<li><tt>contains(obj)</tt>: while moving through the pointer chain in the hash table,
the test for equality now becomes this:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">if</span> <span class="br0">&#40;</span>n.<span class="me1">ptr</span>.<span class="me1">data</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span></pre></div>
   
</li>
<li>
<tt>rehash</tt>: simply traverse the linked list, adding each node <tt>p</tt> into the
newly created hash table according the index <tt>hash(p.data)</tt>.
</li>

<li><tt>add(elt)</tt>: after testing <tt>contains</tt>,
do an <tt>addLast(elt)</tt> on the linked list, retrieving a pointer, <tt>p</tt> to
the added <tt>ListNode</tt> node, then:
<div class='format_display'>
<span></span>
<pre class="java">bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span> <span class="sy0">=</span> <span class="kw1">new</span> Node<span class="br0">&#40;</span>p, bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div>
 
</li>
<li><tt>remove(obj)</tt>: after testing <tt>contains</tt>, obtain the <tt>ListNode</tt>
pointer <tt>p</tt> for the <tt>obj</tt> in the linked list. Using <tt>p.next</tt> and
<tt>p.prev</tt> we can reroute the linked list around <tt>p</tt>, thereby removing it.
A useful helper function is this modification of <tt>contains</tt>:
<div class='format_display'>
<span></span>
<pre class="java"><span class="kw1">private</span> Node search<span class="br0">&#40;</span><span class="kw3">Object</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span> index <span class="sy0">=</span> hash<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="sy0">;</span>
  Node n <span class="sy0">=</span> bucket<span class="br0">&#91;</span>index<span class="br0">&#93;</span><span class="sy0">;</span>
  <span class="kw1">while</span> <span class="br0">&#40;</span>n <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span> n.<span class="me1">ptr</span>.<span class="me1">data</span>.<span class="me1">equals</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span> 
      <span class="kw1">break</span><span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      n <span class="sy0">=</span> n.<span class="me1">next</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
  <span class="kw1">return</span> n<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div>
Invoking <tt>Node n = search(obj)</tt> indicates whether <tt>contains</tt> should be true or not
by testing <tt>n != null</tt>; furthermore <tt>ListNode p = n.ptr</tt> becomes the <tt>ListNode</tt>
we want to remove from the linked list.

</li>
</ol>
</div><!--content-->


<script type="text/javascript" src="/javascript/jquery-1.6.4.min.js"></script>
<script type="text/javascript" src="/~rkline/js/init.js"></script>




<p></p>
<div style="font-size:80%;line-height:13px;padding-bottom:5px;">
<hr />
<span style='float:right'>&copy; Robert M. Kline</span>
<div class='print_hide'>
&nbsp;
<div>
</div>

</body>
</html>
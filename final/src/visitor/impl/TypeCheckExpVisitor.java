package visitor.impl;import ram15compiler.ErrorMsg;import ram15compiler.SemanticException;import symboltable.RamMethod;import syntaxtree.*;public class TypeCheckExpVisitor extends TypeDepthFirstVisitor {    private ErrorMsg errors;    public TypeCheckExpVisitor() {        errors = ErrorMsg.getInstance();    }    // Exp e1,e2;    @Override    public Type visit(And n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof BooleanType)) {            errors.addError(new SemanticException("Left side of And must be of type Bool"));            return null;        }        if (!(t2 instanceof BooleanType)) {            errors.addError(new SemanticException("Right side of And must be of type Bool"));            return null;        }        return new BooleanType();    }    @Override    public Type visit(Or n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof BooleanType)) {            errors.addError(new SemanticException("Left side of Or must be of type Bool"));            return null;        }        if (!(t2 instanceof BooleanType)) {            errors.addError(new SemanticException("Right side of Or must be of type Bool"));            return null;        }        return new BooleanType();    }    // Exp e1,e2;    @Override    public Type visit(LessThan n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof IntegerType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        if (!(t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Right side of LessThan must be of type integer"));            return null;        }        return new BooleanType();    }    @Override    public Type visit(Equals n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!((t1 instanceof BooleanType && t2 instanceof BooleanType) ||                (t1 instanceof IntegerType && t2 instanceof IntegerType) ||                (t1 instanceof BooleanType && t2 instanceof IntegerType) ||                (t1 instanceof IntegerType && t2 instanceof BooleanType))) {            errors.addError(new SemanticException("Either side of equals must be int or bool"));            return null;        }        return new BooleanType();    }    // Exp e1,e2;    @Override    public Type visit(Plus n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof IntegerType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        if (!(t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Right side of LessThan must be of type integer"));            return null;        }        return new IntegerType();    }    // Exp e1,e2;    @Override    public Type visit(Minus n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof IntegerType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        if (!(t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Right side of LessThan must be of type integer"));            return null;        }        return new IntegerType();    }    // Exp e1,e2;    @Override    public Type visit(Times n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof IntegerType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        if (!(t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Right side of LessThan must be of type integer"));            return null;        }        return new IntegerType();    }    // Exp e1,e2;    @Override    public Type visit(ArrayLookup n) {        Type t1 = n.e1.accept(this);        Type t2 = n.e2.accept(this);        if (t1 == null || t2 == null) return null;        if (!(t1 instanceof IntArrayType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        if (!(t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Right side of LessThan must be of type integer"));            return null;        }        return new IntegerType();    }    @Override    public Type visit(Slice n) {        Type t1 = n.e1.accept(this);        if (t1 == null) return null;        if (!(t1 instanceof IntArrayType)) {            errors.addError(new SemanticException("slice can only be applied to type int[]"));            return null;        }        if (n.e2 != null) {            Type t2 = n.e2.accept(this);            if (t2 == null) return null;            if (!(t2 instanceof IntegerType)) {                errors.addError(new SemanticException("slice lower bound must be of type integer"));                return null;            }        }        if (n.e3 != null) {            Type t3 = n.e3.accept(this);            if (t3 == null) return null;            if (!(t3 instanceof IntegerType)) {                errors.addError(new SemanticException("slice upper bound must be of type integer"));                return null;            }        }        return new IntArrayType();    }    // Exp e;    @Override    public Type visit(ArrayLength n) {        Type t1 = n.e.accept(this);        if (t1 == null) return null;        if (!(t1 instanceof IntArrayType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        return new IntegerType();    }    // Exp e;    // Identifier i;    // ExpList el;    @Override    public Type visit(Call n) {        Type t = n.e.accept(this);        if (t == null) return null;        if (!(t instanceof IdentifierType)) {            errors.addError(new SemanticException("method " + n.i.toString()                    + "called  on something that is not a"                    + " class or Object."));            return null;        }        String mname = n.i.toString();        String cname = ((IdentifierType) t).s;        RamMethod calledMethod = TypeCheckVisitor.symbolTable.getMethod(mname, cname);        if (calledMethod == null) return null;        for (int i = 0; i < n.el.size(); i++) {            Type t1 = null;            Type t2 = null;            if (calledMethod.getParamAt(i) != null) {                t1 = calledMethod.getParamAt(i).type();            }            t2 = n.el.elementAt(i).accept(this);            if (!TypeCheckVisitor.symbolTable.compareTypes(t1, t2)) {                errors.addError(new SemanticException("Type Error in arguments passed to "                        + cname + "." + mname));                return null;            }        }        return TypeCheckVisitor.symbolTable.getMethodType(mname, cname);    }    // int i;    @Override    public Type visit(IntegerLiteral n) {        return new IntegerType();    }    @Override    public Type visit(True n) {        return new BooleanType();    }    @Override    public Type visit(False n) {        return new BooleanType();    }    // String s;    @Override    public Type visit(IdentifierExp n) {        return TypeCheckVisitor.symbolTable.getVarType(TypeCheckVisitor.currMethod,                TypeCheckVisitor.currClass, n.s);    }    @Override    public Type visit(This n) {        return TypeCheckVisitor.currClass.type();    }    // Exp e;    @Override    public Type visit(NewArray n) {        Type t1 = n.e.accept(this);        if (t1 == null) return null;        if (!(t1 instanceof IntegerType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        return new IntArrayType();    }    // Identifier i;    @Override    public Type visit(NewObject n) {        return new IdentifierType(n.i.s);    }    // Exp e;    @Override    public Type visit(Not n) {        Type t1 = n.e.accept(this);        if (t1 == null) return null;        if (!(t1 instanceof BooleanType)) {            errors.addError(new SemanticException("Left side of LessThan must be of type integer"));            return null;        }        return new BooleanType();    }    @Override    public Type visit(ParenExp n) {        return n.e1.accept(this);    }}
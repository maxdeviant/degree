package visitor;import symboltable.RamClass;import symboltable.RamMethod;import symboltable.Table;import syntaxtree.*;public class TypeCheckVisitor extends DepthFirstVisitor {    static RamClass currentClass;    static RamMethod currentMethod;    static Table symbolTable;    public TypeCheckVisitor(Table symbolTable) {        TypeCheckVisitor.symbolTable = symbolTable;    }    @Override    public void visit(Program n) {        n.mainClass.accept(this);        for (int i = 0; i < n.classDeclList.size(); i++) {            n.classDeclList.elementAt(i).accept(this);        }    }    @Override    public void visit(MainClass n) {        String i1 = n.identifier.toString();        currentClass = symbolTable.getClass(i1);        n.identifierTwo.accept(this);        n.statement.accept(this);    }    @Override    public void visit(ClassDeclExtends n) {        String id = n.identifier.toString();        currentClass = symbolTable.getClass(id);        n.identifierTwo.accept(this);        for (int i = 0; i < n.varDeclList.size(); i++) {            n.varDeclList.elementAt(i).accept(this);        }        for (int i = 0; i < n.methodDeclList.size(); i++) {            n.methodDeclList.elementAt(i).accept(this);        }    }    @Override    public void visit(ClassDeclSimple n) {        String id = n.identifier.toString();        currentClass = symbolTable.getClass(id);        for (int i = 0; i < n.varDeclList.size(); i++) {            n.varDeclList.elementAt(i).accept(this);        }        for (int i = 0; i < n.methodDeclList.size(); i++) {            n.methodDeclList.elementAt(i).accept(this);        }    }    @Override    public void visit(VarDecl n) {        n.type.accept(this);        n.identifier.accept(this);    }    @Override    public void visit(MethodDecl n) {        n.type.accept(this);        String id = n.identifier.toString();        currentMethod = currentClass.getMethod(id);        Type retType = currentMethod.type();        for (int i = 0; i < n.formalList.size(); i++) {            n.formalList.elementAt(i).accept(this);        }        for (int i = 0; i < n.varDeclList.size(); i++) {            n.varDeclList.elementAt(i).accept(this);        }        for (int i = 0; i < n.statementList.size(); i++) {            n.statementList.elementAt(i).accept(this);        }        if (!symbolTable.compareTypes(retType, n.exp.accept(new TypeCheckExpVisitor()))) {            System.out.println("Wrong return type for method " + id);            System.exit(0);        }    }    @Override    public void visit(Formal n) {        n.type.accept(this);        n.identifier.accept(this);    }    @Override    public void visit(If n) {        if (!(n.exp.accept(new TypeCheckExpVisitor()) instanceof BooleanType)) {            System.out.println("The condition of while must be" + "of type boolean");            System.exit(-1);        }        n.statement.accept(this);        n.statementTwo.accept(this);    }    @Override    public void visit(While n) {        if (!(n.exp.accept(new TypeCheckExpVisitor()) instanceof BooleanType)) {            System.out.println("The condition of while must be" + "of type boolean");            System.exit(-1);        }        n.statement.accept(this);    }    @Override    public void visit(Print n) {        for (int i = 0; i < n.expList.size(); i++) {            n.expList.elementAt(i).accept(this);            if (!(n.expList.elementAt(i).accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {                System.out.println("The argument of System.out.println must be" + " of type int");                System.exit(-1);            }        }    }    @Override    public void visit(Assign n) {        Type t1 = symbolTable.getVarType(currentMethod, currentClass, n.identifier.toString());        Type t2 = n.exp.accept(new TypeCheckExpVisitor());        if (!symbolTable.compareTypes(t1, t2)) {            System.out.println("Type error in assignment to " + n.identifier.toString());            System.exit(0);        }    }    @Override    public void visit(ArrayAssign n) {        Type typeI = symbolTable.getVarType(currentMethod, currentClass, n.identifier.toString());        if (!(typeI instanceof IntArrayType)) {            System.out.println("The identifier in an array assignment" + "must be of type int []");            System.exit(-1);        }        if (!(n.lhs.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {            System.out.println("The first expression in an array assignment" + "must be of type int");            System.exit(-1);        }        if (!(n.lhs.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {            System.out.println("The second expression in an array assignment" + "must be of type int");            System.exit(-1);        }    }}
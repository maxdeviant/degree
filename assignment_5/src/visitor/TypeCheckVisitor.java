package visitor;import symboltable.RamClass;import symboltable.RamMethod;import symboltable.Table;import syntaxtree.*;public class TypeCheckVisitor extends DepthFirstVisitor {    static RamClass currClass;    static RamMethod currMethod;    static Table symbolTable;    public TypeCheckVisitor(Table s) {        symbolTable = s;    }    // MainClass mainClass;    // ClassDeclList classDeclList;    public void visit(Program n) {        n.mainClass.accept(this);        for (int i = 0; i < n.classDeclList.size(); i++) {            n.classDeclList.elementAt(i).accept(this);        }    }    // Identifier identifier,identifierTwo;    // Statement string;    public void visit(MainClass n) {        String i1 = n.identifier.toString();        currClass = symbolTable.getClass(i1);        n.identifierTwo.accept(this);        n.statement.accept(this);    }    // Identifier identifier;    // VarDeclList varDeclList;    // MethodDeclList methodDeclList;    public void visit(ClassDeclSimple n) {        String id = n.identifier.toString();        currClass = symbolTable.getClass(id);        for (int i = 0; i < n.varDeclList.size(); i++) {            n.varDeclList.elementAt(i).accept(this);        }        for (int i = 0; i < n.methodDeclList.size(); i++) {            n.methodDeclList.elementAt(i).accept(this);        }    }    // Identifier identifier;    // Identifier identifierTwo;    // VarDeclList varDeclList;    // MethodDeclList methodDeclList;    public void visit(ClassDeclExtends n) {        String id = n.identifier.toString();        currClass = symbolTable.getClass(id);        n.identifierTwo.accept(this);        for (int i = 0; i < n.varDeclList.size(); i++) {            n.varDeclList.elementAt(i).accept(this);        }        for (int i = 0; i < n.methodDeclList.size(); i++) {            n.methodDeclList.elementAt(i).accept(this);        }    }    // Type type;    // Identifier identifier;    public void visit(VarDecl n) {        n.type.accept(this);        n.identifier.accept(this);    }    // Type type;    // Identifier identifier;    // FormalList formalList;    // VarDeclList varDeclList;    // StatementList statementList;    // Exp lhs;    public void visit(MethodDecl n) {        n.type.accept(this);        String id = n.identifier.toString();        currMethod = currClass.getMethod(id);        Type retType = currMethod.type();        for (int i = 0; i < n.formalList.size(); i++) {            n.formalList.elementAt(i).accept(this);        }        for (int i = 0; i < n.varDeclList.size(); i++) {            n.varDeclList.elementAt(i).accept(this);        }        for (int i = 0; i < n.statementList.size(); i++) {            n.statementList.elementAt(i).accept(this);        }        if (symbolTable.compareTypes(retType, n.exp.accept(new TypeCheckExpVisitor())) == false) {            System.out.println("Wrong return type for method " + id);            System.exit(0);        }    }    // Type type;    // Identifier identifier;    public void visit(Formal n) {        n.type.accept(this);        n.identifier.accept(this);    }    // Exp lhs;    // Statement statement,statementTwo;    public void visit(If n) {        if (!(n.exp.accept(new TypeCheckExpVisitor()) instanceof BooleanType)) {            System.out.println("The condition of while must be" +                    "of type boolean");            System.exit(-1);        }        n.statement.accept(this);        n.statementTwo.accept(this);    }    // Exp lhs;    // Statement string;    public void visit(While n) {        if (!(n.exp.accept(new TypeCheckExpVisitor()) instanceof BooleanType)) {            System.out.println("The condition of while must be" + "of type boolean");            System.exit(-1);        }        n.statement.accept(this);    }    // Exp lhs;    public void visit(Print n) {        if (!(n.e.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {            System.out.println("The argument of System.out.println must be" + " of type int");            System.exit(-1);        }    }    // Identifier identifier;    // Exp lhs;    public void visit(Assign n) {        Type t1 = symbolTable.getVarType(currMethod, currClass, n.identifier.toString());        Type t2 = n.exp.accept(new TypeCheckExpVisitor());        if (symbolTable.compareTypes(t1, t2) == false) {            System.out.println("Type error in assignment to " + n.identifier.toString());            System.exit(0);        }    }    // Identifier identifier;    // Exp lhs,rhs;    public void visit(ArrayAssign n) {        Type typeI = symbolTable.getVarType(currMethod, currClass, n.identifier.toString());        if (!(typeI instanceof IntArrayType)) {            System.out.println("The identifier in an array assignment" +                    "must be of type int []");            System.exit(-1);        }        if (!(n.lhs.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {            System.out.println("The first expression in an array assignment" +                    "must be of type int");            System.exit(-1);        }        if (!(n.lhs.accept(new TypeCheckExpVisitor()) instanceof IntegerType)) {            System.out.println("The second expression in an array assignment" +                    "must be of type int");            System.exit(-1);        }    }}
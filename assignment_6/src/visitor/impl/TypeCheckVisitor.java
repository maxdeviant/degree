package visitor.impl;import ram15compiler.ErrorMsg;import ram15compiler.SemanticException;import symboltable.RamClass;import symboltable.RamMethod;import symboltable.Table;import syntaxtree.*;public class TypeCheckVisitor extends DepthFirstVisitor {    static RamClass currClass;    static RamMethod currMethod;    static Table symbolTable;    private ErrorMsg errors;    public TypeCheckVisitor(Table s) {        symbolTable = s;        errors = ErrorMsg.getInstance();    }    // Identifier i1,i2;    // Statement s;    @Override    public void visit(MainClass n) {        String i1 = n.i1.toString();        currClass = symbolTable.getClass(i1);        n.i2.accept(this);        n.s.accept(this);    }    // Identifier identifier;    // VarDeclList vl;    // MethodDeclList ml;    @Override    public void visit(ClassDeclSimple n) {        String id = n.i.toString();        currClass = symbolTable.getClass(id);        for (int i = 0; i < n.vl.size(); i++) {            n.vl.elementAt(i).accept(this);        }        for (int i = 0; i < n.ml.size(); i++) {            n.ml.elementAt(i).accept(this);        }    }    // Type t;    // Identifier identifier;    // FormalList fl;    // VarDeclList vl;    // StatementList statementList;    // Exp exp;    @Override    public void visit(MethodDecl n) {        n.t.accept(this);        String id = n.i.toString();        currMethod = currClass.getMethod(id);        Type retType = currMethod.type();        for (int i = 0; i < n.fl.size(); i++) {            n.fl.elementAt(i).accept(this);        }        for (int i = 0; i < n.vl.size(); i++) {            n.vl.elementAt(i).accept(this);        }        for (int i = 0; i < n.sl.size(); i++) {            n.sl.elementAt(i).accept(this);        }        if (!symbolTable.compareTypes(retType, n.e.accept(new TypeCheckExpVisitor()))) {            errors.addError(new SemanticException("Wrong return type for method " + id));            return;        }    }    // Exp exp;    // Statement s1,s2;    @Override    public void visit(If n) {        Type t1 = n.e.accept(new TypeCheckExpVisitor());        if (t1 == null) return;        if (!(t1 instanceof BooleanType)) {            errors.addError(new SemanticException("The condition of while must be" +                    "of type boolean"));            return;        }        n.s1.accept(this);        n.s2.accept(this);    }    // Exp exp;    // Statement s;    @Override    public void visit(While n) {        Type t1 = n.e.accept(new TypeCheckExpVisitor());        if (t1 == null) return;        if (!(t1 instanceof BooleanType)) {            errors.addError(new SemanticException("The condition of while must be" +                    "of type boolean"));            return;        }        n.s.accept(this);    }    // Exp exp;    @Override    public void visit(Print n) {        for (int i = 0; i < n.el.size(); i++) {            Type t1 = n.el.elementAt(i).accept(new TypeCheckExpVisitor());            if (t1 == null) return;            if (!(t1 instanceof IntegerType)) {                errors.addError(new SemanticException("The argument of Print must be" +                        " of type int"));                return;            }        }    }    @Override    public void visit(Println n) {        for (int i = 0; i < n.el.size(); i++) {            Type t1 = n.el.elementAt(i).accept(new TypeCheckExpVisitor());            if (t1 == null) return;            if (!(t1 instanceof IntegerType)) {                errors.addError(new SemanticException("The argument of Println must be" +                        " of type int"));                return;            }        }    }    // Identifier identifier;    // Exp exp;    @Override    public void visit(Assign n) {        Type t1 = symbolTable.getVarType(currMethod, currClass, n.identifier.toString());        Type t2 = n.exp.accept(new TypeCheckExpVisitor());        if (!symbolTable.compareTypes(t1, t2)) {            errors.addError(new SemanticException("Type error in assignment to " + n.identifier.toString()));            return;        }    }    @Override    public void visit(PlusEquals n) {        Type t1 = symbolTable.getVarType(currMethod, currClass, n.i.toString());        Type t2 = n.e.accept(new TypeCheckExpVisitor());        if (t2 == null) return;        if (!(t1 instanceof IntegerType && t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Both sides of PlusEquals must be of type int"));            return;        }    }    @Override    public void visit(MinusEquals n) {        Type t1 = symbolTable.getVarType(currMethod, currClass, n.i.toString());        Type t2 = n.e.accept(new TypeCheckExpVisitor());        if (t2 == null) return;        if (!(t1 instanceof IntegerType && t2 instanceof IntegerType)) {            errors.addError(new SemanticException("Both sides of MinusEquals must be of type int"));            return;        }    }    // Identifier identifier;    // Exp lhs,rhs;    @Override    public void visit(ArrayAssign n) {        Type typeI = symbolTable.getVarType(currMethod, currClass, n.identifier.toString());        if (!(typeI instanceof IntArrayType)) {            errors.addError(new SemanticException("The identifier in an array assignment" +                    "must be of type int []"));            return;        }        Type t1 = n.lhs.accept(new TypeCheckExpVisitor());        Type t2 = n.rhs.accept(new TypeCheckExpVisitor());        if (t1 == null || t2 == null) return;        if (!(t1 instanceof IntegerType)) {            errors.addError(new SemanticException("The first expression in an array assignment" +                    "must be of type int"));            return;        }        if (!(t2 instanceof IntegerType)) {            errors.addError(new SemanticException("The second expression in an array assignment" +                    "must be of type int"));            return;        }    }}
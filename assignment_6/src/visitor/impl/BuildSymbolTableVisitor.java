package visitor.impl;import ram15compiler.ErrorMsg;import ram15compiler.SemanticException;import symboltable.RamClass;import symboltable.RamMethod;import symboltable.Table;import symboltable.impl.TableImpl;import syntaxtree.*;public class BuildSymbolTableVisitor extends TypeDepthFirstVisitor {    private Table symbolTable;    private RamClass currClass;    private RamMethod currMethod;    private ErrorMsg errors;    public BuildSymbolTableVisitor() {        symbolTable = new TableImpl();        errors = ErrorMsg.getInstance();    }    public Table getSymTab() {        return symbolTable;    }    // MainClass m;    // ClassDeclList cl;    @Override    public Type visit(Program n) {        n.m.accept(this);        for (int i = 0; i < n.cl.size(); i++) {            n.cl.elementAt(i).accept(this);        }        return null;    }    // Identifier i1,i2;    // Statement s;    @Override    public Type visit(MainClass n) {        symbolTable.addClass(n.i1.toString());        currClass = symbolTable.getClass(n.i1.toString());        // Ugly hack -- creating        // new IdentifierType("void") and new IdentifierType("String[]");        // not worth defining a VoidType and StringAryType        // for just a few occurrences        symbolTable.getClass(n.i1.s).addMethod("main", new IdentifierType("void"));        currMethod = symbolTable.getClass(n.i1.toString()).getMethod("main");        symbolTable.getMethod("main",                currClass.getId()).addParam(n.i2.toString(), new IdentifierType("String[]"));        n.s.accept(this);        currMethod = null;        return null;    }    // Identifier identifier;    // VarDeclList vl;    // MethodDeclList ml;    @Override    public Type visit(ClassDeclSimple n) {        if (!symbolTable.addClass(n.i.toString())) {            errors.addError(new SemanticException("Class " + n.i.toString()                    + "is already defined"));            return null;        }        currClass = symbolTable.getClass(n.i.toString());        for (int i = 0; i < n.vl.size(); i++) {            n.vl.elementAt(i).accept(this);        }        for (int i = 0; i < n.ml.size(); i++) {            n.ml.elementAt(i).accept(this);        }        return null;    }    // Type t;    // Identifier identifier;    @Override    public Type visit(VarDecl n) {        Type t = n.t.accept(this);        if (t == null) return null;        String id = n.i.toString();        if (currMethod == null) {            if (!currClass.addVar(id, t)) {                errors.addError(new SemanticException(id + "is already defined in "                        + currClass.getId()));                return null;            }        } else {            if (!currMethod.addVar(id, t)) {                errors.addError(new SemanticException(id + "is already defined in "                        + currClass.getId() + "."                        + currMethod.getId()));                return null;            }        }        return null;    }    // Type t;    // Identifier identifier;    // FormalList fl;    // VarDeclList vl;    // StatementList statementList;    // Exp exp;    @Override    public Type visit(MethodDecl n) {        Type t = n.t.accept(this);        if (t == null) return null;        String id = n.i.toString();        if (!currClass.addMethod(id, t)) {            errors.addError(new SemanticException("Method " + id                    + "is already defined in "                    + currClass.getId()));            return null;        }        currMethod = currClass.getMethod(id);        for (int i = 0; i < n.fl.size(); i++) {            n.fl.elementAt(i).accept(this);        }        for (int i = 0; i < n.vl.size(); i++) {            n.vl.elementAt(i).accept(this);        }        for (int i = 0; i < n.sl.size(); i++) {            n.sl.elementAt(i).accept(this);        }        n.e.accept(this);        currMethod = null;        return null;    }    // Type t;    // Identifier identifier;    @Override    public Type visit(Formal n) {        Type t = n.t.accept(this);        if (t == null) return null;        String id = n.i.toString();        if (!currMethod.addParam(id, t)) {            errors.addError(new SemanticException("Formal" + id + "is already defined in "                    + currClass.getId() + "."                    + currMethod.getId()));            return null;        }        return null;    }    @Override    public Type visit(IntArrayType n) {        return n;    }    @Override    public Type visit(BooleanType n) {        return n;    }    @Override    public Type visit(IntegerType n) {        return n;    }    // String s;    @Override    public Type visit(IdentifierType n) {        return n;    }}